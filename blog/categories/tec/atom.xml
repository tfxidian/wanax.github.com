<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://sonnewilling.com/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://sonnewilling.com/"/>
  <updated>2014-05-07T12:02:10+08:00</updated>
  <id>http://sonnewilling.com/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于C的Socket聊天服务器]]></title>
    <link href="http://sonnewilling.com/blog/2014/05/05/ji-yu-cshi-de-socketliao-tian-fu-wu-qi/"/>
    <updated>2014-05-05T16:26:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/05/05/ji-yu-cshi-de-socketliao-tian-fu-wu-qi</id>
    <content type="html"><![CDATA[<p>前段时间使用C借助libevent，glib实现了一个简单的可以单聊，群聊的服务器，今天因为需求有些改动所以又翻出来改了一下。果然一日不见如隔三秋，虽说是自己写的东西，但基本上已经忘得七七八八了。觉得有必要在这里记录一下，省得以后又悲剧。</p>

<h2>一，工具类</h2>

<h3>1.libunp.a</h3>

<p>用到的第一个库便是它，因为它是《UNIX网络编程》的示例代码的工具库&hellip;开头写的测试程序基本都是照着示例代码改来改去，自然也是用的一样的函数来实现。觉得对于一般的读写和各种包裹函数都是很有用的。具体的不用细说，还是认真翻书来得实在。</p>

<h3>2.GLib</h3>

<h4>GHashTable</h4>

<p>这里基本的数据结构如哈希表之类的使用了GLib来做主角，另外它的GString也很好用，可以很方便的初始化与格式化字符串，个人感觉比C风格的字符串要好用一些。</p>

<p>GLib哈希表支持各种不同的结构，如果觉得<code>int</code>,<code>string</code>不够用可以直接使用指针，对于我来说已经相当足够。</p>

<p><code>c
GHashTable *user_to_bev_map = g_hash_table_new(g_direct_hash,g_direct_equal);
g_hash_table_insert(user_to_bev_map, GINT_TO_POINTER(u_id), GINT_TO_POINTER(bev));
struct bufferevent *bev = g_hash_table_lookup(user_to_bev_map,GINT_TO_POINTER(to_id));
</code></p>

<p><code>g_direct_hash</code>,<code>g_direct_equal</code>代表初始化的类型，详细的介绍如下:</p>

<blockquote><p>Hash values returned by hash_func are used to determine where keys are stored within the GHashTable data structure.</p>

<p>The <code>g_direct_hash()</code>, <code>g_int_hash()</code>, <code>g_int64_hash()</code>, <code>g_double_hash()</code> and <code>g_str_hash()</code> functions are provided for some common types of keys.</p>

<p>If hash_func is NULL, g_direct_hash() is used.</p></blockquote>

<!-- more -->


<h4>GString</h4>

<p>相比于C风格的字符串需要定长初始化，拼接赋值之类的，GString提供的字符串要人性化很多，还内置了长度的属性，可以很方便的调用。</p>

<p><code>c
GString *sql = g_string_sized_new(0);
g_string_printf(sql,"INSERT INTO table (id, type) VALUES (%s, %s);",id,type);
g_string_erase(sql, 0, sql-&gt;len);
g_string_free(sql,1);
</code></p>

<p>还可以很方便的重复使用，但不要忘记最后的释放，关于释放函数的第二个参数是这样说明的：</p>

<blockquote><p>If free_segment is TRUE it also frees the character data. If it&rsquo;s FALSE, the caller gains ownership of the buffer and must free it after use with g_free().</p></blockquote>

<p>还有个常用的函数是<code>g_strsplit</code>，可以对字符进行分割,第三个参数表明需要分出几个来，0的话则一直切分到最后。</p>

<p>```c</p>

<pre><code>gchar **p = g_strsplit(line,",",0);
dispatch_request(source_id-&gt;str, p[3], p[0], p[2], p[1], p[4]);
g_strfreev(p);
</code></pre>

<p>```</p>

<p>当然，关于GLib还有很多有用的东西，用Dash下个文档慢慢翻着看一遍相信会很有收获的。</p>

<h3>3.Mysql</h3>

<p>有服务的地方就有数据库，对于这种简易的小服务，Mysql是必不可少的。</p>

<p>针对Mysql封了三个简单的函数方便调用：</p>

<p>```c</p>

<pre><code>MYSQL *db_connect(char *url, char *user_name, char *pwd, char *table_name) {
    MYSQL *conn_ptr;
    conn_ptr = mysql_init(NULL);
    if (!conn_ptr) {
        printf("mysql_init failed\n");
        return NULL;
    }
    conn_ptr = mysql_real_connect(conn_ptr, url, user_name, pwd, table_name, 0, NULL, 0);
    mysql_set_character_set(conn_ptr,"utf8");
    if (conn_ptr) {
        return conn_ptr;
    } else {
        return NULL;
    }
}
</code></pre>

<p>```</p>

<p>```c</p>

<pre><code>MYSQL_RES *db_query(MYSQL *conn_ptr, char *sql) {
    int res = mysql_query(conn_ptr, sql); //查询语句
    if (res) {
        printf("error:%s\n",mysql_error(conn_ptr));
        return NULL;
    } else {
        MYSQL_RES *res_ptr = mysql_store_result(conn_ptr);              //取出结果集
        printf("affected %lu rows\n",(unsigned long)mysql_affected_rows(conn_ptr));
        return res_ptr;
    }
}
</code></pre>

<p>```</p>

<p>返回的<code>res_ptr</code>需要手动释放：</p>

<p>```c</p>

<pre><code>mysql_free_result(res);
</code></pre>

<p>```
还有一个关闭函数：</p>

<p>```c</p>

<pre><code>void db_close(MYSQL *connfd) {
    mysql_close(connfd);
}
</code></pre>

<p>```
这样，在服务器起来时建立数据库的连接存为全局变量，每次直接拿来用就好了，下面是一个比较典型的使用场景：</p>

<p>```c</p>

<pre><code>GString *sql = g_string_sized_new(0);
g_string_printf(sql,"INSERT INTO table (id, type) VALUES (%s, %s);",id,type);
db_query(conn_ptr, sql-&gt;str);
g_string_erase(sql, 0, sql-&gt;len);
g_string_printf(sql,"SELECT uid FROM table WHERE pid = %s",target_id);
printf("find users sql2:%s\n", sql-&gt;str);
MYSQL_RES *res = db_query(conn_ptr, sql-&gt;str);
MYSQL_ROW sqlrow;
if (res) {
    while((sqlrow = mysql_fetch_row(res)))  {
        long to_id = strtol(sqlrow[0], NULL, 10);
        if (g_hash_table_contains(user_to_bev_map,GINT_TO_POINTER(to_id)) &amp;&amp; strcmp(sqlrow[0],source_id)) {
            struct bufferevent *bev = g_hash_table_lookup(user_to_bev_map,GINT_TO_POINTER(to_id));
            evbuffer_add_printf ((struct evbuffer *)bufferevent_get_output(bev), "%s\n",send_msg-&gt;str);
        }
    }
}
mysql_free_result(res);
g_string_free(sql,1);
g_string_free(send_msg,1);
</code></pre>

<p>```</p>

<h3>4.libevent</h3>

<h4>介绍</h4>

<p>libevent是个好东西，有了它一般的数量级的连接都不在话下了。关于这种大数量的连接是有专门的话题来讨论的-<a href="http://www.kegel.com/c10k.html">C10K</a>。</p>

<p>最开始尝试了多进程多线程，select阻塞之类的方法，最后才找到这里来，也算是按着故事的发展逻辑走了一遍符合剧情尿性吧&hellip;<a href="http://daniel.haxx.se/docs/poll-vs-select.html">这篇文章</a>写得不错，比较有指导性。</p>

<p>关于libevent上手说不上难，狠下心来多读几遍它的<a href="http://www.wangafu.net/~nickm/libevent-book/">Fast portable non-blocking network programming with Libevent</a>弄明白了个大概还是不成问题的。</p>

<p>它的优点是跨平台，可以针对不同的平台的阻塞实现相同的功能。对于我们来说只需要关心event这个东西就好了，至于是UNIX的select，Linux的epoll还是BSD的kqueue那是libevent的事情，它会在底层帮我们选择<a href="http://monkey.org/~provos/libevent/doxygen-2.0.1/">libevent Documentation</a>。</p>

<h4>原理</h4>

<p>原始的socket的连接是我们建立了连接，获得一个套接字，然后对这个套接字进行多路复用的读写。</p>

<p>而现在我们可以使用libevent提供的event将这个套接字包裹起来，针对这个event编写它特定的读写函数。因为libevent是事件驱动的，所以当读写缓冲区达到特定条件时便会自动调用我们事先定义好的函数进行逻辑处理。大大简化了编码人员的工作量，可以让我们将更多的精力集中到逻辑代码的编写上面来（恰恰是最无聊的部分&hellip;），所以这么看来，也算是对程序员傻瓜化了一下吧。</p>

<p>因为对event的读写涉及到缓冲区的东西，需要我们去按字节的读出来，这里libevent也很贴心的又帮我们简化了一下工作。除了event外还提供了<a href="http://www.wangafu.net/~nickm/libevent-book/Ref6_bufferevent.html">bufferevent</a>，看名字便知道这是专门针对读写字符准备的。这是网站上对它的介绍：</p>

<blockquote><p>Most of the time, an application wants to perform some amount of data buffering in addition to just responding to events.</p>

<p>When we want to write data, for example, the usual pattern runs something like:</p>

<ul>
<li><p>Decide that we want to write some data to a connection;</p></li>
<li><p>Put that data in a buffer.Wait for the connection to become writable;</p></li>
<li><p>Write as much of the data as we can;</p></li>
<li><p>Remember how much we wrote, and if we still have more data to write, wait for the connection to become writable again.</p></li>
</ul>


<p>This buffered IO pattern is common enough that Libevent provides a generic mechanism for it. A &ldquo;bufferevent&rdquo; consists of an underlying transport (like a socket), a read buffer, and a write buffer. Instead of regular events, which give callbacks when the underlying transport is ready to be read or written, a bufferevent invokes its user-supplied callbacks when it has read or written enough data.</p></blockquote>

<h4>使用</h4>

<p>我们可以将新建的监听套接字绑定在event上帮我们处理后续的事件：</p>

<p>```c</p>

<pre><code>struct event_base *base;
struct event *listener_event;
serveListen(&amp;listener);
evutil_make_socket_nonblocking(listener);
listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void *)base);
event_add(listener_event, NULL);
event_base_dispatch(base);
</code></pre>

<p>```</p>

<p>当有事件进入时它会主动调用<code>do_accept</code>：</p>

<p>```c
void do_accept(evutil_socket_t listener, short event, void *arg)
{</p>

<pre><code> struct event_base *base = arg;
struct sockaddr_storage ss;
socklen_t slen = sizeof(ss);
int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
if (fd &lt; 0) {
    perror("accept");
} else if (fd &gt; FD_SETSIZE) {
    close(fd);
} else {
    struct bufferevent *bev;
    evutil_make_socket_nonblocking(fd);
    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, readcb, writecb, errorcb, GINT_TO_POINTER(fd));
    bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
    bufferevent_enable(bev, EV_READ|EV_WRITE);
}
</code></pre>

<p>}
```</p>

<p>从上面代码可以看出，我们从<code>accept</code>中接收回一个套接字，并将该套接字绑定在一个<code>bufferevent</code>，设置好相应的读写函数与读写触发的水位线加入到<code>base</code>里便可以从容的等待事件的触发了。</p>

<p>关于水位线，这里也有段详细的描述：</p>

<blockquote><p>Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write &ldquo;watermarks&rdquo; of the bufferevent.</p>

<p>Every bufferevent has four watermarks:</p>

<ul>
<li><code>Read low-water mark</code></li>
</ul>


<p>Whenever a read occurs that leaves the bufferevent’s input buffer at this level or higher, the bufferevent’s read callback is invoked. Defaults to 0, so that every read results in the read callback being invoked.</p>

<ul>
<li><code>Read high-water mark</code></li>
</ul>


<p>If the bufferevent’s input buffer ever gets to this level, the bufferevent stops reading until enough data is drained from the input buffer to take us below it again. Defaults to unlimited, so that we never stop reading because of the size of the input buffer.</p>

<ul>
<li><code>Write low-water mark</code></li>
</ul>


<p>Whenever a write occurs that takes us to this level or below, we invoke the write callback. Defaults to 0, so that a write callback is not invoked unless the output buffer is emptied.</p>

<ul>
<li><code>Write high-water mark</code></li>
</ul>


<p>Not used by a bufferevent directly, this watermark can have special meaning when a bufferevent is used as the underlying transport of another bufferevent. See notes on filtering bufferevents below.</p></blockquote>

<p>细读一遍还是蛮获益匪浅的，大体意思为通过水位线的设置来触发读写的回调函数。</p>

<ul>
<li><p>对于读取水位，有读低水位与高水位，读低水位默认为0，即当buffer里数据量高于0时便会调用读回调，也就是一有数据便会回调，另一方面，当超过读的高水位时，buffer便会停止接受数据，这个值默认被置为<code>unlimited</code>，所以可以理解为永远不会停止接受数据。</p></li>
<li><p>对于写入水位，写的低水位表示当写出数据后buffer里剩余的数据量小于该水位时调用写函数，默认为0，即只有buffer被清空后该函数才会被回调。写的高水位比较特殊，一般情况下没有使用。</p></li>
</ul>


<p>对于水位线的设置是通过下面的函数实现的</p>

<p><code>c
void bufferevent_setwatermark(struct bufferevent *bufev, short events,size_t lowmark, size_t highmark);
ex:bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
</code></p>

<p>在回调函数里这样获取数据：</p>

<p>```c</p>

<pre><code>struct evbuffer *input = bufferevent_get_input(bev);
if ((line = evbuffer_readln(input, &amp;n, EVBUFFER_EOL_LF))) {
    gchar **p;
    p = g_strsplit(line,",",0);
    dispatch_request(u_data-&gt;u_id-&gt;str, p[3], p[0], p[2], p[1], p[4]);
    g_strfreev(p);
}
</code></pre>

<p>```</p>

<p>需要注意的是，提供的<code>evbuffer_readln</code>可以将接受到的一行数据自动去除<code>\n</code>，方便了我们的后期使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android USB Host通信]]></title>
    <link href="http://sonnewilling.com/blog/2014/04/30/android-usb-hosttong-xin/"/>
    <updated>2014-04-30T11:18:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/04/30/android-usb-hosttong-xin</id>
    <content type="html"><![CDATA[<h2>开了个头</h2>

<p>一部Android手机加上一块Arduino的板子通过USB通信可以实现很多有趣的东西。</p>

<p>2011年Google推出Android开放配件协议AOA及配件开发工具包ADK提供了Android USB或蓝牙进行通信的API，为基于Android系统的智能设备控制外设提供了条件。利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备 <a href="http://www.chinaaet.com/article/216691">原文</a>。</p>

<!-- more -->


<p>想来这便是Android的魅力所在，开源的Linux系统给了任何人实现自己的梦想的可能。无需再依靠大的厂商提供的一套套完整的服务。仅仅通过自己的想象力配以几块平淡无奇的板子，便能实现一些之前看起来很高大上的东西。</p>

<h2>利其器</h2>

<p>1.Android-<a href="http://developer.android.com/sdk/index.html">ADT</a></p>

<p>Android的简单开发依赖于工具包SDK和开发工具IDE的使用。Google为我们提供的ADT打包了完善的开发工具：</p>

<blockquote><p>Eclipse + ADT plugin</p>

<p>Android SDK Tools</p>

<p>Android Platform-tools</p>

<p>The latest Android platform</p>

<p>The latest Android system image for the emulator</p></blockquote>

<p>这里还不得不提的是一个关于Android模拟器的问题。用过eclipse的都知道，上面自带的模拟器速度奇慢，尤其当适应了iPhone开发后对其更是不能忍受。这里有一篇文章便是专门讲解了下为毛Android的模拟器这么慢-<a href="http://stackoverflow.com/questions/1584617/simulator-or-emulator-what-is-the-difference">Simulator or Emulator</a>。</p>

<p>然后便发现了这个神器-<a href="http://www.genymotion.com/">Genymotion</a>，感觉这玩意儿比苹果的模拟器还快。</p>

<p>2.<a href="http://www.arduino.cc/">Arduino</a></p>

<p>这个板子还是蛮便宜又好用的，官网的文档也全，基本跟着读一遍就知道大体的开发的流程了，提供的IDE有点坑，只能设为9号字体，倒是可以调大，调大的话光标根本对不上&hellip;</p>

<p><img src="/images/tec/androidusb/arduino.png" alt="image" /></p>

<p>示例的代码做了个简单的读数据的功能，每次读一行然后原样返回。</p>

<p>开头的setup那里设置了<a href="http://en.wikipedia.org/wiki/Baud">波特率</a>，大体上波特率跟每秒发送的信息量有关。手上的这块板子经过简单的测试，有如下数据：</p>

<blockquote><p>波特率为9600时，每次可以携带129个字节，间隔极限在150ms</p>

<p>波特率为14400时，每次可以携带191个字节，间隔极限在260ms</p></blockquote>

<p>个人推测大概越好的板子每次能携带的信息量越大且时间间隔越短吧，即所谓的可以支持很高的波特率。</p>

<p>有了上面这两套东西基本上就可以开始USB通信了。</p>

<h2>幕前</h2>

<p>关于详细的实现Google的教程上有个快速简易的介绍，一般跟着做是可以实现效果的-<a href="http://developer.android.com/guide/topics/connectivity/usb/index.html">USB Host and Accessory</a>。稍微了解过Android开发的看着玩意儿没啥问题。基本上就是在<code>manifest</code>里对指定的activity配置下权限就妥了，它还提供了一个<code>device_filter</code>的xml文件，可以过滤指定的USB设备。</p>

<p>因为要在Andorid上做开发然后测试与Arduino，所以免不了要先往Android上写程序再让这俩东西连接，老是这样往复的在几台设备间插拔效率太低，Google提供给我们的解决方案是让Android通过Wifi连电脑，然后Android与Arduino一直连着线就妥了。</p>

<p>照着试了几遍，别人的电脑一连就妥，我的死活不行，也不知是不是苹果机的缘故。无奈实在没有插来插去的兴趣，所以又研究了下Genymotion，因为它是依托在VirtualBox上的，总觉得可以一搞。</p>

<p>多次尝试后发现，可以先将Arduino板插上电脑，如下图会出现这个设备，添加虚拟机对它的过滤，这之后把板子拔下来再插回去的话虚拟机也即Android模拟器便可以接收到Arduino板子的信号了。想要对板子连电脑烧程序的话，则反过来，先取消对板子的过滤，插拔一次便连上电脑了。</p>

<p><img src="/images/tec/androidusb/usbbox.png" alt="image" /></p>

<p>具体的实现大体分为四步：<a href="http://developer.android.com/guide/topics/connectivity/usb/index.html">USB Host and Accessory</a></p>

<h4>一，Obtaining permission to communicate with a device</h4>

<p>先实例化一个<code>UsbManager</code>，通过它来获取USB连接的权限。</p>

<p>```java
UsbManager mUsbManager = (UsbManager) getSystemService(Context.USB_SERVICE);
private static final String ACTION_USB_PERMISSION =</p>

<pre><code>"com.android.example.USB_PERMISSION";
</code></pre>

<p>mPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);
IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
registerReceiver(mUsbReceiver, filter);
UsbDevice device;
mUsbManager.requestPermission(device, mPermissionIntent);
<code>
权限获取：
</code>java
private static final String ACTION_USB_PERMISSION =</p>

<pre><code>"com.android.example.USB_PERMISSION";
</code></pre>

<p>private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (ACTION_USB_PERMISSION.equals(action)) {
        synchronized (this) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                if(device != null){
                  //call method to set up device communication
               }
            } 
            else {
                Log.d(TAG, "permission denied for device " + device);
            }
        }
    }
}
</code></pre>

<p>};
```</p>

<h4>二，Enumerating devices</h4>

<p>```java
HashMap&lt;String, UsbDevice> deviceList = manager.getDeviceList();
Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();
while(deviceIterator.hasNext()){</p>

<pre><code>UsbDevice device = deviceIterator.next()
//your code
</code></pre>

<p>}
```</p>

<h4>三，Communicating with a device</h4>

<p><code>java
private Byte[] bytes
private static int TIMEOUT = 0;
private boolean forceClaim = true;
UsbInterface intf = device.getInterface(0);
UsbEndpoint endpoint = intf.getEndpoint(0);
UsbDeviceConnection connection = mUsbManager.openDevice(device);
connection.claimInterface(intf, forceClaim);
connection.bulkTransfer(endpoint, bytes, bytes.length, TIMEOUT); //do in another thread
</code></p>

<h4>四，Terminating communication with a device</h4>

<p>```java
BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction(); 
  if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
        UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
        if (device != null) {
            // call your method that cleans up and closes communication with the device
        }
    }
}
</code></pre>

<p>};
```</p>

<p>需要注意的是两者间的通讯都是以Byte形式完成的，所以作为在接收与发送的时候需要注意相关的转码工作，而且我这边实现的是一行行的读取，所以发送的时候会隐式地拼接上<code>\n</code>。</p>

<p>发送时的转码：</p>

<p>```java
private String changeEscapeSequence(String in) {</p>

<pre><code>String out = new String();
try {
    out = unescapeJava(in);
} catch (IOException e) {
    return "";
}
out = out + "\n";
return out;
</code></pre>

<p>} <br/>
private String unescapeJava(String str) throws IOException {</p>

<pre><code> if (str == null) {
     return "";
 }
 int sz = str.length();
 StringBuffer unicode = new StringBuffer(4);
 StringBuilder strout = new StringBuilder();
 boolean hadSlash = false;
 boolean inUnicode = false;
 for (int i = 0; i &lt; sz; i++) {
     char ch = str.charAt(i);
     if (inUnicode) {
         // if in unicode, then we're reading unicode
         // values in somehow
         unicode.append(ch);
         if (unicode.length() == 4) {
             // unicode now contains the four hex digits
             // which represents our unicode character
             try {
                 int value = Integer.parseInt(unicode.toString(), 16);
                 strout.append((char) value);
                 unicode.setLength(0);
                 inUnicode = false;
                 hadSlash = false;
             } catch (NumberFormatException nfe) {
                 // throw new NestableRuntimeException("Unable to parse unicode value: " + unicode, nfe);
                 throw new IOException("Unable to parse unicode value: " + unicode, nfe);
             }
         }
         continue;
     }
     if (hadSlash) {
         // handle an escaped value
         hadSlash = false;
         switch (ch) {
             case '\\':
                 strout.append('\\');
                 break;
             case '\'':
                 strout.append('\'');
                 break;
             case '\"':
                 strout.append('"');
                 break;
             case 'r':
                 strout.append('\r');
                 break;
             case 'f':
                 strout.append('\f');
                 break;
             case 't':
                 strout.append('\t');
                 break;
             case 'n':
                 strout.append('\n');
                 break;
             case 'b':
                 strout.append('\b');
                 break;
             case 'u':
                 {
                     // uh-oh, we're in unicode country....
                     inUnicode = true;
                     break;
                 }
             default :
                 strout.append(ch);
                 break;
         }
         continue;
     } else if (ch == '\\') {
         hadSlash = true;
         continue;
     }
     strout.append(ch);
 }
 if (hadSlash) {
     // then we're in the weird case of a \ at the end of the
     // string, let's output it anyway.
     strout.append('\\');
 }
 return new String(strout.toString());
</code></pre>

<p>}
```</p>

<p>接收时的转码：</p>

<p>```java
void setSerialDataToTextView(int disp, byte[] rbuf, int len, String sCr, String sLf) {</p>

<pre><code>for (int i = 0; i &lt; len; ++i) {
    mText.append((char) rbuf[i]);
}
</code></pre>

<p>}
```</p>

<h2>正主</h2>

<p>其实最后在各种测试的时候没有用Google的这个原始流程，在网上发现了一份比较完整的USB通讯示例流程-<a href="https://github.com/ksksue/Android-USB-Serial-Monitor-Lite">Android-USB-Serial-Monitor-Lite</a>，直接用它提供的各种工具做的测试&hellip;我的测试代码在这里<a href="https://github.com/wanax/android_usb_test">android_usb_test</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下的Socket通信-TCP/IP基本概念]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-tcp-slash-ipji-ben-gai-nian/"/>
    <updated>2014-03-20T18:44:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-tcp-slash-ipji-ben-gai-nian</id>
    <content type="html"><![CDATA[<h2>总览</h2>

<blockquote><p>All problems in computer science can be solved by another level of indirection</p></blockquote>

<p>觉得这句话对TCP的分层也很适用。</p>

<p>对TCP/IP协议来说，大体分为五层，</p>

<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ol>


<p>应用层我们接触的比较多，流行的如HTTP，FTP之类都算，像我在大学里做的PHP开发时基本对HTTP发包没有任何概念，照着教程开eclipse，apache，在浏览器里敲个<code>locahost:8080</code>出来个猫的图案就很开心了。再建个index，上面写句“未满18周岁禁止进入”，就有种天下在手的感觉。</p>

<!--more-->


<p>后来做java网站，用到了HttpClient，逐渐对HTTP的抓包发包有了简单地了解。通过这玩意儿就可以做到绕过网页填写，直接后台模拟网页提交表单，那些抢票软件大体上就是这个思路。</p>

<p>再往下便是闻名已久的传输层（TCP,UPD,SCTP etc.）与网络层(IPv4,IPv6 etc.)了。</p>

<h2>网络的划分</h2>

<p><img src="/images/tec/Socket/hierarchy.png" alt="image" /></p>

<p>通过上图可以很直观的看到应用层的实体数据经过层层的包装最终封印在了链路层中在物理层中进行传输。其中每一层实体间交换的单位信息称为<em>协议数据单元(protocol data unit,PDU)</em>。每层的PDU作为下层的<em>数据服务单元（service data unit,SDU）</em>传递给下层，并由下层间接完成本层的PDU交换。</p>

<p>为了避免诸如TCP的PDU，IP的PDU这类很不简洁的称呼，国际上给每层的PDU都另外取了自己的名字。传输层的称为<em>segment（分节）</em>，网络层的称为<em>IP datagram（IP数据报）</em>，链路层的称为<em>frame（帧）</em></p>

<p>而关于层与层间的打包封印也有它们不得不说的故事，那就是分片。简单的说如果本层PDU的大小超过紧邻下层的最大SDU限制，那么本层还要事先把PDU划分成若干个合适的片段让下层分开载送，再在相反方向把这些片段重组成PDU。同一层内SDU作为PDU的净荷（payload）字段出现，因此可以说上层PDU作为本层的SDU字段由本层PDU承载。如上图所示每层PDU除用于承载紧邻上层的PDU（即承载数据外），也用于承载本层协议内部通讯所需的控制信息（各种header）。</p>

<p>当然这只是个初步的说法，下面会针对传输层与网络层展开具体一下的学习。</p>

<h3>1.传输层</h3>

<p>一说传输层TCP，讲不通三次握手连接，四次握手关闭都不好意思出来混。</p>

<h4>先看连接图示：</h4>

<p><img src="/images/tec/Socket/connect.JPG" alt="image" /></p>

<p>图中有类似于SYN，ACK的标记量，结合上一章的内容，其实这也是TCP分节的一种。分节除了用于承载数据外，也用于建立连接（SYN分节），终止连接（FIN分节），中止连接（RST分节），确认数据接收（ACK分节），刷送待发数据（PSH分节）和携带紧急数据指针（URG分节），而且这些功能（包括承载数据）可以灵活组合。</p>

<p>也就是说在建立连接的初期，由Socket自带的函数为我们发送分节握手沟通，握手连接建立后，则由用户自行组织分节信息进行通信。</p>

<p>关于上图的握手过程可以简单复述一下：</p>

<ol>
<li>服务器必须准备好接受外来的连接，这通常通过调用<code>socket</code>,<code>bind</code>,<code>listen</code>这三个函数来完成，称之为<em>被动打开（passive open）</em>。</li>
<li>客户通过调用<code>connect</code>发起<em>主动打开（active open）</em>。这导致客户TCP发送一个SYN（同步）分节，它告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部，一个TCP首部及可能有的TCP选项。</li>
<li>服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。</li>
<li>客户必须确认服务器的SYN。</li>
</ol>


<p>上述过程中出现了<em>SYN_SENT</em>之类的字样，它们代表了套接字的状态。在<code>socket</code>函数初始化后套接字的状态为<em>CLOSED</em>，<code>connect</code>函数导致当前套接字从<em>CLOSED</em>状态转移到<em>SYN_SENT</em>状态，若成功则在转移到<em>ESTABLISHED</em>状态。<em>若<code>connect</code>失败则该套接字不再可用，必须关闭，不可以对这样的套接字再次调用<code>connect</code>函数，而是在每次失败后，必须<code>close</code>当前的套接字描述符并重新调用<code>socket</code></em>。</p>

<h4>再来个关闭图示：</h4>

<p><img src="/images/tec/Socket/close.JPG" alt="image" /></p>

<ol>
<li>某个应用进程首先调用<code>close</code>，称该端执行<em>主动关闭（active close）</em>，该端的TCP于是发送一个FIN终止分节，表示数据发送完毕。</li>
<li>接收到这个FIN对端执行<em>被动关闭（passive close）</em>。这个FIN由TCP确认。它的接收也作为一个<em>文件结束符（end-of-file）</em>传递给接收端应用进程（放在已排队等候该应用进程接收的任何其它数据之后），因为FIN的接收意味着接收端应用进程在相应连接上再无额外的数据可接收。</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用<code>close</code>关闭它的套接字。这导致了它的TCP也发送一个FIN。</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li>
</ol>


<p>在握手连接的过程中，套接字通过发送SYN（建立连接分节）经历了COLSE，SYN_SENT，ESTABLISHED等状态，达到了可以通信的目的。而在四次关闭握手连接中，套接字也要经历几种状态，达到真正关闭的目的，<em>需要注意的是，因为TCP是全双工的，所以正常情况下的关闭需要经过双方的确认才可以完全关闭，这就需要通信两端都分别发送自己的FIN信号，且回应对方的FIN，因此理论上关闭握手需要四次，每个套接字各两次。</em></p>

<ol>
<li>FIN_WAIT_1：<em>主动方</em>套接字在ESTABLISHED状态正常通信时，它想主动关闭连接，于是向对方发送了FIN报文，此时该套接字即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。</li>
<li>FIN_WAIT_2：<em>主动方</em>通俗的讲便是我已经完成任务并且告知对端完成我方的关闭，然后我在等你发送你的FIN，要是你还有什么话说那赶紧，我这边该说的都说完了&hellip;</li>
<li>CLOSE_WAIT：<em>被动方</em>对应的是FIN_WAIT_2状态，便是在正常ESTABLISHED状态下收到了对端的FIN信号，但我还有活没做完，需要搞定后才往你那儿发送FIN终止信号，此时的状态便是CLOSE_WAIT。</li>
<li>LAST_ACK：<em>被动方</em>被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。</li>
<li>TIME_WAIT：<em>主动方</em>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
</ol>


<p>在这些状态中，比较不好理解的是TIME_WAIT状态。我们看到执行主动关闭的一方经历了这个状态。该端点停留在这个状态的持续时间是<em>最长分节生命期（maximum segment lifetime，MSL）</em>的两倍，有时候称之为2MSL。</p>

<p>任何TCP实现都必须为MSL选择一个值。其时间在1分钟到4分钟之间。MSL是任何IP数据报能够在因特网中存活的最长时间。因为每个数据报含有一个称为<em>跳限（hop limit）</em>的8位字段，它的最大值为255.一般上假设：</p>

<blockquote><p>具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒。</p></blockquote>

<p>所以TIME_WAIT状态有两个存在的理由，</p>

<ol>
<li>可靠地实现TCP全双工连接的终止。TCP连接在主动关闭方发送的最后一个ACK(FIN)，有可能丢失，这时被动方会重新发FIN, 如果这时主动方处于CLOSED状态 ，就会响应RST而不是ACK。所以主动方要处于TIME_WAIT状态，而不能是CLOSED。</li>
<li>允许老的重复分节在网络中消逝，因为经过2MSL，上一次连接中所有的重复包都会消失。</li>
</ol>


<p>最后放一张TCP中套接字的状态大图~</p>

<p><img src="/images/tec/Socket/status.png" alt="image" /></p>

<h3>2.网络层</h3>

<p>因为主体是使用TCP的Socket进行编程，这里对网络层的具体细节就不做探讨了。但关于网络层还会牵扯到分片的问题，这里需要重视起来。</p>

<p>在TCP传输层中，发送端TCP把来自应用进程的字节流数据（即由应用进程通过一次次输出操作写出到发送端TCP套接字中的数据）按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据既可能是发送端应用进程单次输出操作的结果，也可能是数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于可在连接建立阶段由对端通告的<em>最大分节大小（maximum segment size,MSS）</em>以及<em>外出接口的最大传输单元（maximum transmission unit,MTU）</em>或<em>外出路径的路径MTU</em>。</p>

<p>MSS的目的是告诉对端其重组缓冲区大小的实际值，从而试图避免分片。MSS经常设置成MTU减去IP和TCP首部的固定长度。</p>

<p>网络层实体间交换的PDU称为IP数据报（IP datagram）,其长度有限：IPv4数据报最大长度65535字节，IPv6S数据报最大65575.发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中发送。链路层实体间交换的PDU称为帧（frame），其长度取决于具体的接口。IP数据报由IP首部和所承载的传输层数据（即网络层的SDU）构成。过长的IP数据报无法封装在单个帧中，需要先对其SDU进行分片（fragmentation），再把分成的各个片段（fragment）冠以新的IP首部封装到多个帧中。在一个IP数据报从源端到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中，而其逆操作即重组（reassembly）一般只发生在目的端。</p>

<p>TCP/IP协议族为提高效率会尽可能避免IP的分片/重组操作：TCP根据MSS和MTU限定每个分节的大小，且在途中尽量避免分片操作。不论是否分片都由IP作为链路层的SDU传入链路层，并由链路层封装在帧中数据称为分组（packet，俗称包）。可见一个分组既可能是一个完整地IP数据报，也可能是某个IP数据报的SDU的一个片段被冠以新的IP首部后的结果。</p>

<h2>下一步</h2>

<p>总结了基本套接字函数的使用与TCP/IP的简单概念，下一步将会着手编写一套客户/服务器的通信演示Demo，会考虑实现线程池来提高并发效率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下的Socket通信-Socket的连接]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-Socket-de-lian-jie/"/>
    <updated>2014-03-20T15:55:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-Socket-de-lian-jie</id>
    <content type="html"><![CDATA[<h2>一.关于Socket</h2>

<p>如我，刚见这个名词的时候不知所云，因为起点就没找对，首先要在基于对UNIX有所了解的情况下才利于开展工作，便是“一切皆文件”。</p>

<p>在UNIX下，一般的文件可以通过open打开，并返回一个小整数作为标记，后续的操作便是针对这个小整数进行读写。这个小整数被称作<em>描述符</em>，描述符只是引用file的proc结构中一个数组的某个元素的下标而已，它可以代表该文件，但并不是文件本身，我们通过它来与文件建立联系，方便操作。</p>

<p>以此为前提，Socket便是一种特殊的文件，通过<em>socket</em>函数可以创建一个套接字（特殊的文件），它也返回给我们一个小整数，以后所有的函数调用就用该描述符来标示这个套接字。</p>

<p>在UNIX下文件的种类有很多，打开与使用的方式虽然遵循着一定的模式，但也不尽相同。比如想打开一个文本文件需要借助open函数，而且在打开的时候需要告诉open函数该文本的路径位置，以明确打开的目标。</p>

<!--more-->


<p>Socket的打开也与之相似，因为它一定程度上可以理解为是一个联网通信的文件，所以如果想要明确打开的目标，肯定不能传送一个本地路径，而要与之相符地传送一个目标IP地址。当然这只是简单的比喻，Socket的建立要比文件要复杂一些，IP地址的设置只是打开过程的一个步骤，因为涉及到了网络的缘故，还需要设置很多参数。毕竟文本文件是自己的，打开的标准关上门来自己做主，怎么方便都好商量。而Socket则不一样，既然是在各种主机间通信，且走的路线均不一样，这就牵扯到了各种配置。</p>

<h2>二.TCP下IPv4的Socket连接</h2>

<h3>1.socket</h3>

<p>让我们来看Socket建立的第一步的函数</p>

<p><code>c
int socket(int family, int type, int protocol);
</code></p>

<p>明显的，单是第一步就比open函数多参数。</p>

<p>其中family参数指明协议族，type指明套接字类型，protocol为某个协议的常值类型，或者设为0。</p>

<h4>socket函数的type常值</h4>

<table>
<thead>
<tr>
<th></th>
<th>       type          </th>
<th>        说明         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> SOCK_STREAM    </td>
<td>    字节流套接字   </td>
</tr>
<tr>
<td></td>
<td> SOCK_DGRAM     </td>
<td>     数据报套接字  </td>
</tr>
<tr>
<td></td>
<td>SOCK_SEQPACKET  </td>
<td>    有序分组套接字 </td>
</tr>
<tr>
<td></td>
<td>   SOCK_RAW     </td>
<td>     原始套接字   </td>
</tr>
</tbody>
</table>


<h4>socket函数protocol常值</h4>

<table>
<thead>
<tr>
<th></th>
<th>    protocol     </th>
<th>        说明         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> IPPROTO_TCP    </td>
<td>    TCP传输协议   </td>
</tr>
<tr>
<td></td>
<td> IPPROTO_UDP    </td>
<td>     UDP传输协议  </td>
</tr>
<tr>
<td></td>
<td> IPPROTO_SCTP   </td>
<td>    SCTP传输协议  </td>
</tr>
</tbody>
</table>


<p>所以如果</p>

<p><code>c
sockfd = socket(AF_INET, SOCK_STREAM, 0);
</code></p>

<p>则表示socket函数创建一个网际（AF_INET）字节流（SOCK_STREAM）套接字。</p>

<h3>2.connect</h3>

<p>第一步的socket函数只是把一些基本的参数设置好并返回了一个描述符，就像安好了电话，但其实并没有开始扯线连接，connect帮我们搞定这一步。</p>

<p><code>c
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
</code></p>

<p>socket是由socket返回的套接字描述符，第二个，第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。套接字地址结构必须含有服务器的IP地址和端口号。</p>

<p>关于sockaddr的结构大体如下：</p>

<p>```c
struct sockaddr_in {</p>

<pre><code>sa_family_t    sin_family; /* address family: AF_INET */
in_port_t      sin_port;   /* port in network byte order */
struct in_addr sin_addr;   /* internet address */
</code></pre>

<p>};
```</p>

<p>对此结构一般的设置方法如下</p>

<p><code>c
bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons(13);//服务器端口
inet_pton(AF_INET, "192.168.105.105", &amp;servaddr.sin_addr);//服务器地址
</code></p>

<p>因为具体的连接动作是使用网络字节序的，并不是我们所见到的诸如<code>192.168.105.105:13</code>之类的表达，所以需要htons与inet_pton进行相应的转换。<em>htons()主机到网络短整数，转换二进制端口号</em>，地址转换函数在地址的文本表达式和它们存放在套接字地址结构中的二进制值之间转换。</p>

<p>如果是写一个客户端的请求程序，那么前两个函数就可以满足要求建立了套接字，下一步的动作便是针对该套接字返回的描述符进行相应的读写便可以了。但要是想做一个服务器端的进程具有监听功能的话则还需要另外下面这三个函数。</p>

<h3>3.bind，listen，accept</h3>

<blockquote><p>打个简单的比喻，建立TCP连接就好比一个电话系统。socket函数等同于有电话可用。connect要求我们知道对方的电话号码并拨打它。bind函数是在告诉别人你的电话号码，这样他们可以呼叫你。listen是打开电话振铃，这样当有个外来呼叫到来时，你可以听到。accept则相当于接电话。</p></blockquote>

<p>对于服务器端的socket addr的初始化如下</p>

<p><code>c
bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sin_family      = AF_INET;
servaddr.sin_port        = htons(SERV_PORT);
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
</code></p>

<p>它区别于客户端的套接字初始化在于第四行，并没有指定目标IP地址，代之的是一个INADDR_ANY的宏，它可以表示我接收来自任何地址的请求。
如果想要真正实现这一目的，我们需要调用bind来告知UNIX系统我这个套接字将被用来接收信号：</p>

<p><code>c
int bind(int sockfd, const stuct sockaddr *myaddr, socklen_t addrlen);
</code></p>

<p>继而取消电话的静音状态：</p>

<p><code>c
int listen(int sockfd, int backlog);
</code></p>

<p>此函数通常应该在调用socket和bind这两个函数之后，并在调用accept之前调用。</p>

<p>关于backlog，是一个设置未完成连接队列与已完成连接队列的参数，这里暂不做细致的探讨了。</p>

<p>最后一步，我们的进程将阻塞于accept的调用中。accept函数由TCP服务器调用，用于从已完成的连接队列头返回下一个已完成连接。关于阻塞函数，看下面这段的讲解：</p>

<blockquote><p>永远阻塞的系统调用是指调用有可能永远无法返回，也可称为慢系统调用（slow system call），多数网络支持函数都属于这一种（accept）。适用于慢系统调用的基本规则是，当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。</p></blockquote>

<p>对于此类错误我们可以通过以下函数进行绕过，</p>

<p>```c
for ( ; ; ) {</p>

<pre><code>    clilen = sizeof(cliaddr);
    if ( (connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) {
        if (errno == EINTR)
            continue;       /* back to for() */
        else
            err_sys("accept error");
    }
}
</code></pre>

<p>```</p>

<p>以上便是一个服务器端的监听套接字的建立过程。</p>

<h3>4.close，shutdown</h3>

<p>有开就有关，关于套接字的关闭我们一般使用close与shutdown来进行控制。</p>

<p>正如我们前面所述，我们通过描述符对套接字进行操作，描述符不过是对file的一个下标而已，如果有多个进程同时使用描述符，则均可以表示为对此file的一个引用。初始的引用值为1，每当调用fork以派生子进程或对打开操作返回的描述符（或其复制品）调用dup以复制描述符时，该file结构的引用计数就递增。相应的close()使相应描述符的引用计数减1，当该描述符引用计数为0时则引发正常TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自的对端确认。如想确实在某个TCP连接上发送FIN，可以改用shutdown。</p>

<h3>5.最后无图无真相:</h3>

<p><img src="/images/tec/Socket/funtime.jpg" alt="image" /></p>

<h2>下一步</h2>

<p>这部分具体介绍了Socket的基本概念与一个客户端和服务端的套接字是怎样一步步建立起来的。但文章中也出现了一些诸如FIN之类的关键字并没有进行详细的解释，在下一章，我会对TCP/IP的一些基本概念进行解释。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GLib编译笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/13/glibbian-yi-bi-ji/"/>
    <updated>2014-03-13T15:38:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/13/glibbian-yi-bi-ji</id>
    <content type="html"><![CDATA[<h3>缘起</h3>

<p>最近做的一个项目是使用C写的，随着项目的深入发现需要通过不同的数据结构来完成需求，自己简单地去编写已经不能满足要求且在健壮性方面也存在着隐患，于是就琢磨着在网上找找看看有没有什么现成的C工具包来用，就这样，发现了GLib。</p>

<p>先来看下维基上的介绍：</p>

<blockquote><p>GLib是一个跨平台的、用C语言编写的库，起初是GTK+的一部分，但到了GTK+第二版，开发者决定把跟图形界面无关的代码分开，这些代码于是就组装成了GLib。GLib提供了多种高级的数据结构，如内存块、双向和单向链表、哈希表、动态字符串等。</p></blockquote>

<p>感觉功能刚好满足需要，类似于C++中的STL，果断搞起。</p>

<!--more-->


<h3>1.下载</h3>

<p>从网上搜索GLib找到了这里<a href="http://www.linuxfromscratch.org/blfs/view/svn/general/glib2.html">Linux From Scratch</a>，下载它的压缩包。</p>

<p>这个网站也把具体的编译安装方式写得很明白。</p>

<blockquote><h3>GLib Dependencies</h3>

<h4>Required</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/libffi.html">libffi-3.0.13</a> and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/python2.html">Python-2.7.6</a></p>

<h4>Recommended</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/pcre.html">PCRE-8.34</a>(built with Unicode properties)</p>

<h4>Optional</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/postlfs/attr.html">attr-2.4.47</a>, <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/dbus.html">D-Bus-1.8.0</a> (required to run the tests), and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/gtk-doc.html">GTK-Doc-1.20</a></p>

<h4>Additional Runtime Dependencies</h4>

<p>Quoted directly from the INSTALL file: “Some of the mimetype-related functionality in GIO requires the update-mime-database and update-desktop-database utilities”, which are part of <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/shared-mime-info.html">shared-mime-info-1.2</a> and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/desktop-file-utils.html">desktop-file-utils-0.22</a>, respectively.</p></blockquote>

<p>就是说想要安装GLib的话最起码得先把Required和Recommended里的东西装完才行。</p>

<h3>2.编译</h3>

<p>安装环境配好后就可以正式安装了，顺着那个网页往下走就能看到具体的方法：</p>

<p><code>c
./configure --prefix=/usr --with-pcre=system &amp;&amp; make
</code>
再然后</p>

<p><code>c
sudo make install
</code>
GLib在gcc里的使用是借助了一个叫pkg-configure的工具，这玩意儿的作用这位哥儿们说得很详细了，看他的介绍吧：<a href="http://www.chenjunlu.com/2011/03/understanding-pkg-config-tool/">理解 pkg-config 工具</a></p>

<p>其实定位到<code>/usr/lib/pkgconfigure</code>后会发现它里面放了很多你自己安装的库的.pc的配置文件，用vim随便打开一个发现它的内容是这样的：</p>

<p><code>c
   prefix=/usr
   exec_prefix=${prefix}
   libdir=${exec_prefix}/lib
   includedir=${prefix}/include
&amp;
   glib_genmarshal=glib-genmarshal
   gobject_query=gobject-query
   glib_mkenums=glib-mkenums
&amp;
   Name: GLib
   Description: C Utility Library
   Version: 2.38.2
   Requires.private: libpcre
   Libs: -L${libdir} -lglib-2.0 -lintl
   Libs.private:   -lpcre  -lintl  -liconv
   Cflags: -I${includedir}/glib-2.0 -I${libdir}/glib-2.0/include
</code>
看一下就明白了，基本上就是帮你写了一堆编译选项，免得到时候自己编译的时候要敲一坨，而且在不同的电脑上编译的时候也可以动态的调整路径，不用一遍遍的去改Makefile。</p>

<p>比如说自己编译一个使用了GLib的文件，可以这样敲：</p>

<p><code>c
gcc `pkg-config --cflags --libs glib-2.0`  hello.c -o hello
</code></p>

<p>–cflags 参数可以给出在编译时所需要的选项，而 –libs 参数可以给出连接时的选项。</p>

<p>当然如果不使用pkg-configure的话也可以类似这样子：</p>

<p><code>c
gcc  -L/usr/lib -I/usr/lib/glib/include/glib-2.0 hello.c -o hello -liconv -lresolv -lpcre -lintl -lglib-2.0
</code>
所以基本上还是简化了很多操作的。</p>

<h3>3.测试使用</h3>

<p>测试一下GLib中哈希表的使用吧：</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;glib.h></h1>

<p>int main(){</p>

<pre><code>    printf("Glib version: %u.%u.%u\n\n",glib_major_version,glib_minor_version,glib_micro_version);
</code></pre>

<p>&amp;</p>

<pre><code>    GHashTable* hash = g_hash_table_new(g_str_hash, g_str_equal);
    g_hash_table_insert(hash, "Virginia", "Richmond");
    g_hash_table_insert(hash, "Texas", "Austin");
    g_hash_table_insert(hash, "Ohio", "Columbus");
</code></pre>

<p>&amp;</p>

<pre><code>    printf("There are %d keys in the hash\n",g_hash_table_size(hash));
    printf("The capital of Texas is %s\n",g_hash_table_lookup(hash, "Texas"));
    gboolean found = g_hash_table_remove(hash, "Virginia");
    printf("The value 'Virginia' was %sfound and removed\n", found ? "" : "not ");
</code></pre>

<p>&amp;</p>

<pre><code>    g_hash_table_destroy(hash);
    return 0;
</code></pre>

<p>}
```
可以打印如下信息：</p>

<blockquote><p>Glib version: 2.38.2</p>

<p>There are 3 keys in the hash</p>

<p>The capital of Texas is Austin</p>

<p>The value &lsquo;Virginia&rsquo; was found and removed</p></blockquote>

<h3>4.搭配Eclipse</h3>

<p>嫌敲命令行麻烦的话也可以配到Eclipse上用。现在在Eclipse上有了pkg-configure的插件，可以对GLib直接勾选使用，但我安装后没有起到效果，不知道哪里出了问题<a href="https://code.google.com/p/pkg-config-support-for-eclipse-cdt/">pkg-config-support-for-eclipse-cdt</a>。但反正原理已经知道了，索性自己配一下也就妥了。</p>

<p>选中工程，在Project里找到Properties进入到下图的界面：</p>

<p><img src="/images/tec/GLib/eclipsecon.png" alt="image" /></p>

<p>在Libraries里配置GLib库的位置和名字，在Includes里配置GLib头文件的位置，我的头文件在这里</p>

<p><code>c
/usr/include/glib-2.0
</code>
其实按照教程正常安装的话基本上都会在这个位置，这样的话就可以用Eclipse在GLib里爽起来了~</p>
]]></content>
  </entry>
  
</feed>
