<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://sonnewilling.com/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://sonnewilling.com/"/>
  <updated>2016-10-19T20:40:36+08:00</updated>
  <id>http://sonnewilling.com/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS图形原理与离屏渲染]]></title>
    <link href="http://sonnewilling.com/blog/2016/10/19/iostu-xing-yuan-li-yu-chi-ping-xuan-ran/"/>
    <updated>2016-10-19T20:28:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2016/10/19/iostu-xing-yuan-li-yu-chi-ping-xuan-ran</id>
    <content type="html"><![CDATA[<p><em>Outline</em>:</p>

<p>一，<a href="#anchor1.0">iOS图形显示基本知识</a></p>

<p>&mdash;&mdash;&mdash; 1.1 <a href="#anchor1.1">图形显示原理</a></p>

<p>&mdash;&mdash;&mdash; 1.2 <a href="#anchor1.2">iOS的显示架构</a></p>

<p>&mdash;&mdash;&mdash; 1.3 <a href="#anchor1.3">iOS图形显示流程</a></p>

<p>&mdash;&mdash;&mdash; 1.4 <a href="#anchor1.4">补充知识</a></p>

<p>&mdash;&mdash;&mdash;&mdash;&mdash; 1.4.1 <a href="#anchor1.4.1">图像多层次的合成&mdash;为何设置透明会增加GPU工作量</a></p>

<p>&mdash;&mdash;&mdash;&mdash;&mdash; 1.4.2 <a href="#anchor1.4.2">图层对其&mdash;为何图片缩放会增加GPU工作量</a></p>

<p>&mdash;&mdash;&mdash;&mdash;&mdash; 1.4.3 <a href="#anchor1.4.3">关于卡顿的简单原理解释</a></p>

<p>二，<a href="#anchor2.0">iOS中离屏渲染相关知识</a></p>

<p>&mdash;&mdash;&mdash; 2.1 <a href="#anchor2.1">什么是离屏渲染</a></p>

<p>&mdash;&mdash;&mdash; 2.2 <a href="#anchor2.2">为什么要谨慎避免离屏渲染</a></p>

<p>&mdash;&mdash;&mdash; 2.3 <a href="#anchor2.3">离屏渲染与光栅化</a></p>

<p>&mdash;&mdash;&mdash; 2.4 <a href="#anchor2.4">一些触发离屏渲染的基本case与替换方式</a></p>

<p>三，<a href="#anchor3.0">iOS的一些显示性能检测方法的简单介绍</a></p>

<p>&mdash;&mdash;&mdash; 3.1 <a href="#anchor3.1">显示性能检测一些小Tip</a></p>

<p>&mdash;&mdash;&mdash; 3.2 <a href="#anchor3.2">Instruments &ndash; Core Animation</a></p>

<p>&mdash;&mdash;&mdash; 3.3 <a href="#anchor3.3">Instruments &ndash; OpenGL ES</a></p>

<p>四，<a href="#anchor4.0">AsyncDisplayKit分享</a></p>

<p>&mdash;&mdash;&mdash; 4.1 <a href="#anchor4.1">AsyncDisplayKit是干什么的</a></p>

<p>&mdash;&mdash;&mdash; 4.2 <a href="#anchor4.2">AsyncDisplayKit的一些性能上的优势</a></p>

<h3><span id="anchor1.0">一，iOS图形显示基本知识</span></h3>

<p>从一个像素点到真正显示在屏幕上，iOS到底在里面做了哪些工作，涉及到哪些Frameworks与Libraries？这是这一章想搞明白的问题。</p>

<!--more-->


<h4>1.1 <span id="anchor1.1">图形显示原理</span></h4>

<p>图像想显示到屏幕上使人肉眼可见都需借助像素的力量。简单地说，每个像素由红，绿，蓝三种颜色组成，它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。</p>

<p>计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为<a href="https://www.zhihu.com/question/29163054">光栅化</a>，就是从矢量的点线面的描述，变成像素的描述。</p>

<p><img src="/images/tec/offscreen/offscreen011.png" width="250" alt="image" /></p>

<p>回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>如在 iPhone5 的上就有1,136×640=727,040个像素，而在15寸Retain的MBP上，这一数字达到15.5百万以上，当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，计算量可想而知。</p>

<h4>1.2 <span id="anchor1.2">iOS的显示架构</span></h4>

<p>从软件层面上，iOS借助<code>Core Graohics</code>，<code>Core Animation</code>，<code>Core Image</code>完成图形的处理，它们又都是借助<code>OpenGL ES</code>来完成底层的工作，其结构如下图所示：</p>

<p><img src="/images/tec/offscreen/arch01.png" width="500" alt="image" /></p>

<p>Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它并发的本性让它能高效的将不同纹理合成起来。因为涉及到各种图形矩阵的计算，它跟CPU最直观的区别在于浮点计算能力要超出CPU很多。所以在开发中，<strong>我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理</strong>，因为涉及到光栅化等一些工作时，CPU也会参与进来，这点在后面再详细描述。</p>

<p><code>GPU Driver</code> 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.</p>

<p><code>OpenGL</code>(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p>

<p>OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>在硬件层面的调度我们可以看下图所示：</p>

<p><img src="/images/tec/offscreen/arch03.png" width="500" alt="image" /></p>

<p>计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>

<p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p>

<h4>1.3 <span id="anchor1.3">iOS图形显示流程</span></h4>

<p>我们可以再从上层看一下iOS中不同的Frameworks和Libraries之间的一些联系：</p>

<p><img src="/images/tec/offscreen/offscreen06.png" width="500" alt="image" /></p>

<p>在最顶层的就是UIKit，一个在iOS中用来管理用户图形交互的Objc高级的框架，它由一系列的集合类构成，例如UIButton、UILabel，每一个都负责他们指定的UI Control角色。UIKit本身构建在一个叫Core Animation的框架之上。最后一部分是Core Graphics，曾经在Quartz（一个基于CPU的绘制引擎，在OS X系统上初次露脸）中被引入。这两个较为底层的框架都是用C语言编写的。</p>

<p>我们经常说到的硬件加速其实是指OpenGL,Core Animation/UIKit基于GPU之上对计算机图形合成以及绘制的实现，直到目前为止，iOS上的硬件加速能力还是大大领先与android，后者由于依赖CPU的绘制，绝大多数的动画实现都会让人感觉明显的卡顿<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>CoreAnimation的渲染流程可以用下图来概括:</p>

<p><img src="/images/tec/offscreen/offscreen07.png" width="500" alt="image" /></p>

<p>在GPU的渲染过程中,我们能看到顶点着色器与像素着色器参与到图像的处理。</p>

<p>在objc.io中有一篇文章进一步地阐明了顶点着色器与像素着色器 (<a href="http://objccn.io/issue-21-7/">GPU 加速下的图像处理</a>)<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>

<h4>1.4 <span id="anchor1.4">补充知识</span></h4>

<h5>1.4.1 <span id="anchor1.4.1">图像多层次的合成&mdash;为何设置透明会增加GPU工作量</span><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></h5>

<p><em>合成 | Blended</em></p>

<p>在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。</p>

<p>一个不透明的红色盖在蓝色上那我们看到的就是一个蓝色，但一个半透明的红色盖在蓝色让我们得到的却是一个紫色，这便是合成所要做的工作。</p>

<p>我们可以用下面这个公式来计算每一个像素：</p>

<pre><code>R = S + D * ( 1 – Sa )
</code></pre>

<p>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。</p>

<p>假定两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：</p>

<pre><code>R = S
</code></pre>

<p>如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:</p>

<p><img src="/images/tec/offscreen/arch04.png" width="800" alt="image" /></p>

<p>所以当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量</p>

<p>这也是为什么 CALayer 有一个叫做 opaque 的属性了。如果这个属性为 NO，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。</p>

<h5>1.4.2 <span id="anchor1.4.2">图层对齐&mdash;为何图片缩放会增加GPU工作量</span></h5>

<p>当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</p>

<p>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动；当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。</p>

<p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p>

<p>Core Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p>

<p>关于iOS设备的一些尺寸限制可以看这里：<a href="http://iosres.com/">iOSRes</a></p>

<h5>1.4.3 <span id="anchor1.4.3">关于卡顿的简单原理解释</span><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></h5>

<p><img src="/images/tec/offscreen/offscreen022.png" width="500" alt="image" /></p>

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>

<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>

<h3><span id="anchor2.0">二，iOS中离屏渲染相关知识</span></h3>

<h4><span id="anchor2.1">2.1 什么是离屏渲染</span></h4>

<ul>
<li><p>On-Screen Rendering<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p>

<p>  意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p></li>
<li><p>Off-Screen Rendering</p>

<p>  意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p></li>
</ul>


<p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>。</p>

<p>离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup></p>

<p>这里提到的offscreen rendering主要讲的是通过GPU执行的offscreen,事实上还有的offscreen rendering是通过CPU来执行的。</p>

<p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。其它类似cornerRadios, masks, shadows等触发的offscreen是基于GPU的。</p>

<p><strong><em>PS：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程</em></strong></p>

<p>许多人有误区,认为offscreen rendering就是software rendering,只是纯粹地靠CPU运算。实际上并不是的,offscreen rendering是个比较复杂,涉及许多方面的内容。我们在开发应用,提高性能通常要注意的是避免offscreen rendering。不需要纠结和拘泥于它的定义。<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup></p>

<h4><span id="anchor2.2">2.2 为什么要谨慎避免离屏渲染</span></h4>

<p><a href="https://developer.apple.com/videos/#121">WWDC 2011 Understanding UIKit Rendering</a>指出一般导致图形性能的问题大部分都出在了offscreen rendering,因此如果我们发现列表滚动不流畅,动画卡顿等问题,就可以想想和找出我们哪部分代码导致了大量的offscreen 渲染。</p>

<p>离屏渲染主要在两个地方开销较大：</p>

<ol>
<li><p>创建新缓冲区</p>

<p> 要想进行离屏渲染，首先要创建一个新的缓冲区。</p></li>
<li><p>上下文切换</p>

<p> 离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p></li>
</ol>


<h4><span id="anchor2.3">2.3 离屏渲染与光栅化</span></h4>

<p>光栅化的概念前文有介绍，这里再次跟离屏渲染同时提出来是因为在看过的文章中对这两者的区分有些混淆，这里坐下记录。</p>

<p><em>光栅化</em>：</p>

<p>我们屏幕上显示的画面都是由像素组成，而三维物体都是点线面构成的。要让点线面，变成能在屏幕上显示的像素，就需要Rasterize这个过程。就是从矢量的点线面的描述，变成像素的描述。</p>

<ul>
<li>光栅化概念：将图转化为一个个栅格组成的图像</li>
<li>光栅化特点：每个元素对应帧缓冲区中的一像素<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup></li>
</ul>


<p><img src="/images/tec/offscreen/rasterize01.png" width="500" alt="image" /></p>

<p>iOS中，光栅化的过程是将图形转化为可以存储的bitmap，放在缓存中，以被程序循环使用，减少渲染的频率。</p>

<p>我的理解是光栅化是一种特殊的离屏渲染，它的主要工作量集中在CPU上，而不是前文介绍的那种GPU单独开辟缓存进行图形生成计算，并且CPU光栅化完成后会将该bitmap缓存于本地，以便重复利用，它在形式上也是一种离屏渲染，但不属于<code>OpenGL</code>名字中特指的那种GPU新开buffer生成图形的过程。</p>

<p>在<code>CALayer</code>中，设置<code>shouldRasterize = YES</code>便会触发光栅化，且会将光栅化后的内容缓存起来。相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。</p>

<p>因为离屏渲染本身开销较大，所以对于是否需要光栅化，应该因地制宜地使用。且系统设置了对这个光栅化的内存使用限制，有两点需要注意：</p>

<ol>
<li><p>不要过度使用,系统限制了缓存的大小为2.5X Screen Size.</p>

<p> 如果过度使用,超出缓存之后,同样会造成大量的offscreen渲染。</p></li>
<li><p>被光栅化的图片如果超过100ms没有被使用,则会被移除</p>

<p> 因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。</p></li>
</ol>


<h4><span id="anchor2.4">2.4 一些触发离屏渲染的基本case与替换方式</span></h4>

<p>除了上面介绍的光栅化可以触发离屏渲染，还有很多种情况可以触发：</p>

<ul>
<li>圆角（当和maskToBounds一起使用时）</li>
<li>图层蒙版</li>
<li>阴影</li>
</ul>


<p>对于那些需要动画而且要在屏幕外渲染的图层来说，你可以用<code>CAShapeLayer</code>，<code>contentsCenter</code>或者<code>shadowPath</code>来获得同样的表现而且较少地影响到性能<sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup>。</p>

<h3>三，<span id="anchor3.0">iOS的一些显示性能检测方法的简单介绍</span></h3>

<h4>3.1 <span id="anchor3.1">显示性能检测一些小Tip</span></h4>

<ul>
<li><p>关注FPS</p>

<p>  FPS-Frame per Second,帧率或画面更新率是用于测量显示帧数的量度。，一般来说FPS用于描述视频、电子绘图或游戏每秒播放多少帧，而赫兹则描述显示器的画面每秒更新多少次。在实际体验中，60帧相对于30帧有着更好的体验。<sup id="fnref:13"><a href="#fn:13" rel="footnote">13</a></sup></p>

<p>  在开发中，我们应该对FPS的数值保持关注，若发现掉帧严重则可以进一步使用Instruments分析是哪里出现的问题。现在工程里的beta版本的debug包已经附加了此功能。</p></li>
<li><p>CPU &amp;&amp; GPU<sup id="fnref:14"><a href="#fn:14" rel="footnote">14</a></sup></p>

<p>  CPU，中央处理器。GPU，图形处理器。两者都有总线和外界联系，有自己的缓存体系，以及数字和逻辑运算单元。一句话，两者都为了完成计算任务而设计。</p>

<p>  两者的区别在于存在于片内的缓存体系和数字逻辑运算单元的结构差异：CPU虽然有多核，但总数没有超过两位数，GPU的核数远超CPU，被称为众核（NVIDIA Fermi有512个核）。从结果上导致CPU擅长处理具有复杂计算步骤和复杂数据依赖的计算任务，GPU的众核架构非常适合把同样的指令流并行发送到众核上，采用不同的输入数据执行。</p>

<p>  并且GPU拥有为视频运算专门设计的运算单元: 光栅单元和纹理填充单元。是专为图形而生的。</p>

<p>  <img src="/images/tec/offscreen/opti04.png" width="500" alt="image" /></p>

<p>  所以在开发过程中，心中应该有个尺度，对于主线程的UI响应等一些逻辑工作，我们尽量交给CPU来完成，而图形渲染的工作则多交给GPU搞定，检查有没有做无必要的CPU渲染，例如有些地方我们重写了drawRect或开启了光栅化，而其实是我们不需要也不应该的。</p></li>
<li><p>离屏渲染的消耗</p>

<p>  这会耗费GPU的资源，像前面已经分析的到的。offscreen 渲染会导致GPU需要不断地onScreen和offscreen进行上下文切换。</p></li>
<li><p>Blended Layers | Misaligned Images</p>

<p>  检查我们有无过多的合成 | Blending，图片的格式是否为常用格式，大小是否正常。如果一个图片格式不被GPU所支持，则只能通过CPU来渲染。</p></li>
</ul>


<h4>3.2 <span id="anchor3.2">Instruments &ndash; Core Animation</span></h4>

<p>使用Core Animation可以帮助我们通过观察FPS来定位问题所在。如下图所示，两个红框处便是掉帧比较严重的地方，分别是股票详情页与牛圈首页，然后我们在选取此处，观察调用栈，便可以找出哪里吃性能比较严重了。</p>

<p><img src="/images/tec/offscreen/opti01.png" width="500" alt="image" /></p>

<p>又如下图，可以通过勾选不同的选项，观察页面中是否存在，<em>Blended Layers</em>，<em>Misaligned Images</em>等一系列前文提到的可优化点。</p>

<p><img src="/images/tec/offscreen/opti03.png" width="500" alt="image" /></p>

<ul>
<li><p><code>Color Blended Layers</code>，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。<sup id="fnref:15"><a href="#fn:15" rel="footnote">15</a></sup></p></li>
<li><p><code>Color Offscreen-Rendered Yellow</code>，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。</p></li>
<li><p><code>Flash Updated Regions</code>，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。</p></li>
</ul>


<h4>3.3 <span id="anchor3.3">Instruments &ndash; OpenGL ES</span></h4>

<p>OpenGL ES驱动工具可以帮你测量GPU的利用率，同样也是一个很好的来判断和GPU相关动画性能的指示器。它同样也提供了类似Core Animation那样显示FPS的工具</p>

<p><img src="/images/tec/offscreen/opti05.png" width="500" alt="image" /></p>

<p>Renderer Utilization &ndash; 如果这个值超过了~50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。</p>

<p>Tiler Utilization &ndash; 如果这个值超过了~50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。</p>

<h3>四，<span id="anchor4.0">AsyncDisplayKit分享</span></h3>

<h4>4.1 <span id="anchor4.1">AsyncDisplayKit是干什么的</span></h4>

<p>AsyncDisplayKit is an iOS framework that keeps even the most complex user interfaces smooth and responsive. It was originally built to make Facebook&rsquo;s Paper possible, and goes hand-in-hand with pop&rsquo;s physics-based animations — but it&rsquo;s just as powerful with UIKit Dynamics and conventional app designs.<sup id="fnref:16"><a href="#fn:16" rel="footnote">16</a></sup></p>

<h4>4.2 <span id="anchor4.2">AsyncDisplayKit的一些性能上的优势</span></h4>

<p>AsyncDisplayKit Nodes are a thread-safe abstraction layer over UIViews and CALayers:</p>

<p><img src="/images/tec/offscreen/asdk01.png" alt="image" /></p>

<p>If you know how to use views, you know how to use nodes. ASImageNode and the Text Kit-powered ASTextNode can be used just like their UIKit counterparts. Unlike UIKit view hierarchies, node hierarchies for entire screenfuls of content can be initialized and laid out on background threads — and nodes make it easy to take advantage of the multicore CPUs in all current iOS devices.</p>

<p>Nodes have many advantages over views. For example, you can often improve performance by replacing views with layers. Unfortunately, doing so requires the tedious process of porting view-based code to the different API and inevitably risks regressions. With nodes, it’s as easy as:<sup id="fnref:17"><a href="#fn:17" rel="footnote">17</a></sup></p>

<p><img src="/images/tec/offscreen/asdk02.png" width="250" alt="image" /></p>

<p>If you later need to switch from layers back to views, it’s a one-line change! This is a transformational difference. Instead of being cautious of layer-backed UI code, you can use it by default whenever you don’t need touch handling.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">屏幕显示图像的原理</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://objccn.io/issue-3-1/">Getting Pixels onto the Screen</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.cocoachina.com/industry/20130821/6841.html">iOS图形处理和性能</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="https://github.com/100mango/zen/blob/master/WWDC%E5%BF%83%E5%BE%97%EF%BC%9AAdvanced%20Graphics%20and%20Animations%20for%20iOS%20Apps/Advanced%20Graphics%20and%20Animations%20for%20iOS%20Apps.md">WWDC心得与延伸:iOS图形性能 &mdash; 方秋枋</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p><a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/">Compositing</a><a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">卡顿产生的原因和解决方案</a><a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p><a href="http://foggry.com/blog/2015/05/06/chi-ping-xuan-ran-xue-xi-bi-ji/">离屏渲染学习笔记</a><a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p><a href="https://zsisme.gitbooks.io/ios-/content/chapter15/offscreen-rendering.html">ios核心动画高级技巧</a><a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p><a href="http://objccn.io/issue-3-1/">离屏渲染(Offscreen Rendering)</a><a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
<li id="fn:10">
<p><a href="https://github.com/100mango/zen/blob/master/WWDC%E5%BF%83%E5%BE%97%EF%BC%9AAdvanced%20Graphics%20and%20Animations%20for%20iOS%20Apps/Advanced%20Graphics%20and%20Animations%20for%20iOS%20Apps.md">关于offscreen rendering &mdash; 方秋枋</a><a href="#fnref:10" rev="footnote">&#8617;</a></p></li>
<li id="fn:11">
<p><a href="http://www.jianshu.com/p/6d24a4c29e18">iOS 离屏渲染的研究 &mdash; 齐滇大圣</a><a href="#fnref:11" rev="footnote">&#8617;</a></p></li>
<li id="fn:12">
<p><a href="https://zsisme.gitbooks.io/ios-/content/chapter15/offscreen-rendering.html">CAShapeLayer使用方式的介绍</a><a href="#fnref:12" rev="footnote">&#8617;</a></p></li>
<li id="fn:13">
<p><a href="https://zh.wikipedia.org/wiki/%E5%B8%A7%E7%8E%87">帧率 &ndash; wiki</a><a href="#fnref:13" rev="footnote">&#8617;</a></p></li>
<li id="fn:14">
<p><a href="https://www.zhihu.com/question/19903344">CPU 和 GPU 的区别是什么？ &ndash; 王洋子豪</a><a href="#fnref:14" rev="footnote">&#8617;</a></p></li>
<li id="fn:15">
<p><a href="http://www.samirchen.com/use-instruments/">使用 Instruments 做 iOS 程序性能调试</a><a href="#fnref:15" rev="footnote">&#8617;</a></p></li>
<li id="fn:16">
<p><a href="https://github.com/facebook/AsyncDisplayKit">facebook/AsyncDisplayKit</a><a href="#fnref:16" rev="footnote">&#8617;</a></p></li>
<li id="fn:17">
<p><a href="https://code.facebook.com/posts/721586784561674/introducing-asyncdisplaykit-for-smooth-and-responsive-apps-on-ios/">Introducing AsyncDisplayKit: For smooth and responsive apps on iOS</a><a href="#fnref:17" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS New Feature -- 3D Touch]]></title>
    <link href="http://sonnewilling.com/blog/2016/06/01/ios-new-feature-3d-touch/"/>
    <updated>2016-06-01T14:39:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2016/06/01/ios-new-feature-3d-touch</id>
    <content type="html"><![CDATA[<h3>一. 功能介绍</h3>

<p>3D Touch 是苹果公司最新推出的一种应用在手机上的技术，基于iOS9系统与6s设备，它拓展了手机的操作维度，由平面的两维空间空间拓展为立体的三维空间。针对手机屏幕，在纵向上对压按进行响应，由此衍生出更多的操作场景。</p>

<blockquote><p>   With iOS 9, new iPhone models add a third dimension to the user interface.</p>

<ul>
<li><p> A user can now press your Home screen icon to immediately access functionality provided by your app.></p></li>
<li><p>Within your app, a user can now press views to see previews of additional content and gain accelerated access to features.</p></li>
</ul>
</blockquote>

<!--more-->


<p>根据苹果官方文档<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/index.html#//apple_ref/doc/uid/TP40016543-CH1-SW1">Getting Started with 3D Touch</a>介绍，3D touch可增加以下三种UI新体验：</p>

<h4>1. Home Screen Quick Actions</h4>

<p>按压Home screen上特定App图标，提供快捷方式跳转去App的不同功能场景。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/maps_directions_home_2x.png" alt="image" /></p>

<h4>2. Peek and Pop</h4>

<p>App运行中时，按压某个View提供预览功能。</p>

<blockquote><p>You can also enable peek and pop for links in web views, as described in <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW5">Web View Peek and Pop</a>.</p></blockquote>

<p><img src="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_2x.png" alt="image" /></p>

<h4>3. Force Properties</h4>

<blockquote><p>In iOS 9, the <code>UITouch</code> class has two new properties to support custom implementation of 3D Touch in your app: <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITouch_Class/index.html#//apple_ref/occ/instp/UITouch/force">force</a> and <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITouch_Class/index.html#//apple_ref/occ/instp/UITouch/maximumPossibleForce">maximumPossibleForce</a>. For the first time on iOS devices, these properties let you detect and respond to touch pressure in the <code>UIEvent</code> objects your app receives.</p>

<p>The force of a touch has a high dynamic range, available as a floating point value to your app.</p></blockquote>

<h3>二. 特性实现介绍</h3>

<p>App内有统一接口判断当前设备与系统3D Touch是否可用。</p>

<p>```c
override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
if traitCollection.forceTouchCapability == .Available {
    registerForPreviewingWithDelegate(self, sourceView: view)
}
else {
    // Create an alert to display to the user.
    alertController = UIAlertController(title: "3D Touch Not Available", message: "Unsupported device.", preferredStyle: .Alert)
}
</code></pre>

<p>}
```</p>

<h4>1. Home Screen Quick Actions</h4>

<p>基本数据结构：<code>UIApplicationShortcutItem</code></p>

<p>```c
public class UIApplicationShortcutItem : NSObject, NSCopying, NSMutableCopying {</p>

<pre><code>public init(type: String, localizedTitle: String, localizedSubtitle: String?, icon: UIApplicationShortcutIcon?, userInfo: [NSObject : AnyObject]?)
public convenience init(type: String, localizedTitle: String)   
// An application-specific string that identifies the type of action to perform.
public var type: String { get }
// Properties controlling how the item should be displayed on the home screen.
public var localizedTitle: String { get }
public var localizedSubtitle: String? { get }
@NSCopying public var icon: UIApplicationShortcutIcon? { get }
// Application-specific information needed to perform the action.
// Will throw an exception if the NSDictionary is not plist-encodable.
public var userInfo: [String : NSSecureCoding]? { get }
</code></pre>

<p>}
```</p>

<p><code>UIApplicationShortcutItemType</code>与<code>UIApplicationShortcutItemTitle</code>是必填项，其它选填。</p>

<p><em>注意事项：</em></p>

<ol>
<li>快捷标签最多可以创建四个，包括静态的和动态的。</li>
<li>每个标签的题目和icon最多两行，多出的会用&hellip;省略</li>
</ol>


<p>添加<code>ShortcutItem</code>有两种方式：</p>

<ul>
<li><p><strong>Static quick actions</strong></p>

<p>  直接在App的系统plist文件里添加</p>

<p>  <img src="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Art/UIApplicationShortcutItems_plist_editor_2x.png" height="250" width="700" alt="image" /></p></li>
<li><p><strong>Dynamic quick actions</strong></p></li>
</ul>


<p><code>c
lazy var dynamicShortcuts = UIApplication.sharedApplication().shortcutItems ?? []
</code></p>

<p>```c
shortcutItem = UIApplicationShortcutItem(type: selectedShortcutItem.type, localizedTitle: titleTextField.text ?? &ldquo;&rdquo;, localizedSubtitle: subtitleTextField.text, icon: icon, userInfo: [</p>

<pre><code>               AppDelegate.applicationShortcutUserInfoIconKey: pickerView.selectedRowInComponent(0)
           ]
       )
</code></pre>

<p>```</p>

<p><code>c
dynamicShortcuts[selected.row] = updatedShortcutItem
// Update the application's `shortcutItems`.
UIApplication.sharedApplication().shortcutItems = dynamicShortcuts
</code></p>

<p>点击后的事件响应在App delegate里处理：</p>

<p>```c</p>

<pre><code>/* 
    Called when the user activates your application by selecting a shortcut on the home screen, except when 
    application(_:,willFinishLaunchingWithOptions:) or application(_:didFinishLaunchingWithOptions) returns `false`.
    You should handle the shortcut in those callbacks and return `false` if possible. In that case, this 
    callback is used if your application is already launched in the background.
*/
func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: Bool -&gt; Void) {
    let handledShortCutItem = handleShortCutItem(shortcutItem)
    completionHandler(handledShortCutItem)
}
</code></pre>

<p>```</p>

<h4>2. Peek and Pop</h4>

<p>关键数据结构：<code>UIPreviewAction</code></p>

<p>```c
public class UIPreviewAction : NSObject, NSCopying, UIPreviewActionItem {</p>

<pre><code>public var handler: (UIPreviewActionItem, UIViewController) -&gt; Void { get }
public convenience init(title: String, style: UIPreviewActionStyle, handler: (UIPreviewAction, UIViewController) -&gt; Void)
</code></pre>

<p>}
public class UIPreviewActionGroup : NSObject, NSCopying, UIPreviewActionItem {</p>

<pre><code>public convenience init(title: String, style: UIPreviewActionStyle, actions: [UIPreviewAction])
</code></pre>

<p>}
```</p>

<p>```c
lazy var previewActions: [UIPreviewActionItem] = {</p>

<pre><code>    func previewActionForTitle(title: String, style: UIPreviewActionStyle = .Default) -&gt; UIPreviewAction {
        return UIPreviewAction(title: title, style: style) { previewAction, viewController in
            guard let detailViewController = viewController as? DetailViewController,
                      sampleTitle = detailViewController.sampleTitle else { return }
            print("\(previewAction.title) triggered from `DetailViewController` for item: \(sampleTitle)")
        }
    }
    let action1 = previewActionForTitle("Default Action")
    let action2 = previewActionForTitle("Destructive Action", style: .Destructive)
    let subAction1 = previewActionForTitle("Sub Action 1")
    let subAction2 = previewActionForTitle("Sub Action 2")
    let groupedActions = UIPreviewActionGroup(title: "Sub Actions…", style: .Default, actions: [subAction1, subAction2] )
    return [action1, action2, groupedActions]
}()
</code></pre>

<p>```
通过重载</p>

<p><code>c
func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController?
</code>
生成对应的快速预览图，本身重载</p>

<p><code>c
override func previewActionItems() -&gt; [UIPreviewActionItem]
</code>
来生成下一步动作。</p>

<h4>3. Force Properties</h4>

<p>在<code>UITouch</code>对象中新增了<code>force</code>与<code>maximumPossibleForce</code>，可以根据<code>force</code>定制化自己的需求</p>

<p>```c
public class UITouch : NSObject {</p>

<pre><code>// Force of the touch, where 1.0 represents the force of an average touch
@available(iOS 9.0, *)
public var force: CGFloat { get }
// Maximum possible force with this input mechanism
@available(iOS 9.0, *)
public var maximumPossibleForce: CGFloat { get }
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VC USB 串口通信]]></title>
    <link href="http://sonnewilling.com/blog/2014/08/11/vc-usb-chuan-kou-tong-xin/"/>
    <updated>2014-08-11T11:03:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/08/11/vc-usb-chuan-kou-tong-xin</id>
    <content type="html"><![CDATA[<h2>楔子</h2>

<p>前段时间搞完了聊天服务器后也没有很多事情，因为系统瓶颈停留在数据库读写层面，所以研究了一两周的NOSQL和Cache。NOSQL快是快但key-value型的数据结构实在太过简单，感觉真用起来并不是很方便，Cache倒相对来说可行一些，开多一个服务罢了，其实简单的逻辑自己也能实现。就这样纠结来纠结去的，发现其实现在的服务倒也完全够用，压力测试了下，能撑到1500的并发，想来刚上线估计也最多几百号人能同时聊天就不错了，所以就先研究至此，撑不住了再换，不要过早优化嘛。</p>

<!--more-->


<p>就这样决定先找别的事做做，恰好项目里有需要用到Flash的ANE技术来实现Flash与硬件通信，Flash自然不会写，但用VC进行串口通信打包成DLL给Flash调用这个还是可以研究下的。</p>

<p>ANE这里就不再细谈，大体上就是Flash中调用其它语言的一种技术，通过它可以实现一些Flash做不到的东西，比如说底层通信啥的。这里主要讲USB串口通信这一块儿。</p>

<p>串口通信翻了下书发现还是有很多标准的，而现行最流行的就是USB了，所以在网上关于此的资料还是很好找的。</p>

<p>这篇文章的内容主要由三个部分组成：</p>

<ol>
<li>串口连接的建立与简单阻塞通讯</li>
<li>通过API调用自动查询当前插入的USB设备并建立连接</li>
<li>区别于简单阻塞的通讯方式，如重叠IO与事件通知</li>
</ol>


<h2>一，建立连接与阻塞通讯</h2>

<p>在WIN下面，对于串口一类的硬件设备也是认定为文件的一种，所以也可以使用文件的方式来创建打开使用：</p>

<p>```c
HANDLE h_com = CreateFile((LPCWSTR)&ldquo;COM4&rdquo;,   //设备名</p>

<pre><code>                GENERIC_READ || GENERIC_WRITE, //访问模式，可同时读写
                0,                             //共享模式，0表示不共享
                NULL,                          //安全性设置，一般使用NULL
                OPEN_EXISTING,                 //该参数表示该设备必须存在否则创建失败，串口通讯需此设置
                FILE_ATTRIBUTE_NORMAL
                0);
</code></pre>

<p>```</p>

<p>首先初始化一个句柄<code>h_com</code>，让它指向所要打开设备的串口号，之后对该设备的所有操作均需通过该句柄来执行。</p>

<p>之后便是对此串口的一些基本设置，</p>

<h4><em>超时选项</em></h4>

<p><code>c
/*设置串口的超时时间，均设为0，表示不使用超时限制*/
COMMTIMEOUTS  CommTimeouts;
CommTimeouts.ReadIntervalTimeout = 0;
CommTimeouts.ReadTotalTimeoutMultiplier = 0;
CommTimeouts.ReadTotalTimeoutConstant = 0;
CommTimeouts.WriteTotalTimeoutMultiplier = 0;
CommTimeouts.WriteTotalTimeoutConstant = 0;
SetCommTimeouts(h_com, &amp;CommTimeouts);
</code></p>

<h4><em>DCB参数配置</em></h4>

<p>因为DCB结构体中选项较多，故一般的配置方式是先通过<code>GetCommState</code>获取默认的DCB配置选项，再根据个人需求进行相应的修改。</p>

<p>```c
/<em>将ANSI字符串转换为UNICODE字符串</em>/
DWORD dwNum = MultiByteToWideChar(CP_ACP, 0, szDCBparam, -1, NULL, 0);
wchar_t *pwText = new wchar_t[dwNum];
if (!MultiByteToWideChar(CP_ACP, 0, szDCBparam, -1, pwText, dwNum))
{</p>

<pre><code>bIsSuccess = TRUE;
</code></pre>

<p>}
/<em>获取当前串口配置参数，并且构造自定义DCB参数</em>/
bIsSuccess = GetCommState(h_com, &amp;dcb) &amp;&amp; BuildCommDCB(pwText, &amp;dcb);
/<em>开启RTS flow控制</em>/
dcb.fRtsControl = RTS_CONTROL_ENABLE;
dcb.fRtsControl = RTS_CONTROL_ENABLE;
dcb.fBinary = TRUE;
dcb.fParity = TRUE;
dcb.ByteSize = 8;
dcb.Parity = ODDPARITY;
dcb.StopBits = ONESTOPBIT;
delete[] pwText;
SetCommState(h_com, &amp;dcb);
```</p>

<h4><em>清空缓冲区</em></h4>

<p>对句柄进行了一系列操作，保险起见清空一下缓冲区。</p>

<p><code>c
PurgeComm(h_com, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
</code></p>

<p>如此，一个完整的串口句柄就构造完毕了。接下来是进行阻塞读的测试。</p>

<p>首先，我们可以使用<code>ClearCommError</code>这个方法获取当前读缓冲区里的数据大小，通过轮询的方式阻塞在这里，当缓冲区里有数据的时候我们再进行下一步的动作。</p>

<p>```c
int get_dirty_len() {</p>

<pre><code>DWORD dwError = 0;  
COMSTAT  comstat;   
memset(&amp;comstat, 0, sizeof(COMSTAT));
UINT BytesInQue = 0;
if (ClearCommError(h_com, &amp;dwError, &amp;comstat)) {
    BytesInQue = comstat.cbInQue;
}
</code></pre>

<p>}
```</p>

<p>当有数据到来便可以直接读取了：</p>

<p>```c
while(h_comm->is_working) {</p>

<pre><code>int len = get_dirty_len();
if (len == 0) {
    Sleep(SLEEP_TIME_INTERVAL);
    continue;
}
char recv[10];
int recv_len;
ReadFile(h_com, recv, len, &amp;recv_len, NULL);
</code></pre>

<p>}
```</p>

<p>写与读类似</p>

<p><code>c
WriteFile(h_com, send, len, &amp;send_len, NULL);
</code></p>

<p>如上，一个简单的阻塞串口读写Demo便完成了。</p>

<h2>二，检测查询插入的USB设备信息</h2>

<p>因为是Flash直接对DLL调用进行设备连接，所以在C层面需要主动获取连接上的端口名建立连接，并将连接设备的信息返回给Flash调用者，故需要使用另一组工具完成任务。</p>

<p>在WIN下面有一组API可以完成此项功能：</p>

<p><code>c
SetUpAPI
</code></p>

<p>摸索<code>setupapi</code>的使用方法着实费了些力气，归结起来主要有两点</p>

<ol>
<li>英文阅读能力不足，MSDN上面说明的使用方法并没有深刻理解</li>
<li>整体知识把握不足，摸着石头过河，边试边蒙</li>
</ol>


<p>说到底还是要多看书，多读英文资料，大体结构把握了也知道从何下手，而且国内博客的资源大多抄来抄去，并没有多关注其所以然，代码贴来贴去，试着心烦远不如一点一点学起来得畅快。</p>

<p>言归正传，获取端口信息依旧要从句柄入手。</p>

<h4><em>1.借助API获取某一类设备的相关信息</em></h4>

<p>```c
HDEVINFO hDevInfo = SetupDiGetClassDevsA(</p>

<pre><code>    (LPGUID)&amp;GUID_DEVCLASS_PORTS,
    0,
    0,
    DIGCF_PRESENT);
</code></pre>

<p>```</p>

<p>关于<code>LPGUID</code>可以自己初始化，一般的普通设备系统也提供了宏定义，可以看到我这里使用了<code>GUID_DEVCLASS_PORTS</code>，指明需要获取的是<code>PORT</code>（COM端口）一类的设备信息。</p>

<h4><em>2.遍历连接设备，获取设备信息</em></h4>

<p>```c
char szBuf[MAX_PATH];
ZeroMemory(szBuf, MAX_PATH);
int i = 0;
SP_DEVINFO_DATA   spDevInfoData = { sizeof(SP_DEVINFO_DATA) };
for (i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &amp;spDevInfoData); i++) {</p>

<pre><code>char *id = (char *)malloc(10 * sizeof(char));
char *port = (char *)malloc(10 * sizeof(char));
//get ID
if (SetupDiGetDeviceInstanceId(hDevInfo, 
    &amp;spDevInfoData, (PWSTR)szBuf, MAX_PATH, NULL)) {
    char dest[MAX_PATH];
    ZeroMemory(dest, MAX_PATH);
    get_str(szBuf, dest);
    get_id(dest, id);
}
ZeroMemory(szBuf, MAX_PATH);
//get port
if (SetupDiGetDeviceRegistryProperty(hDevInfo, 
    &amp;spDevInfoData, SPDRP_FRIENDLYNAME, NULL, (PBYTE)szBuf, MAX_PATH, NULL)) {
    char dest[MAX_PATH];
    ZeroMemory(dest, MAX_PATH);
    get_str(szBuf, dest);
    get_com(dest, port);
}
strcpy(coms[i], port);
strcpy(vids[i], id);
*len = i;
</code></pre>

<p>}
```</p>

<p><code>c
SetupDiEnumDeviceInfo
</code></p>

<p>这个函数通过<code>Index</code>进行依次查找设备，若设备不存在则返回空终止遍历。</p>

<p>所以在最后我们可以通过初始化的句柄<code>hDevInfo</code>与遍历出来的设备信息<code>spDevInfoData</code>来查找我们想要获取的具体信息。</p>

<h2>三，重叠IO与事件通知</h2>

<h3>重叠IO</h3>

<p>重叠IO解决的是受IO性能的影响不能第一时间将预期的字节数全部读完必须时阻塞等待在<code>ReadFile</code>，待全部数据传输完毕才返回的问题。</p>

<p>简单说来便是假如我想读1000个字节的数据从串口设备，但当前传输速度只有100K/S，那岂不是要在<code>ReadFile</code>上阻塞10s才会返回？正常情况下是这样的，而重叠IO便是解决此一问题的正确方法。</p>

<p>它的大体思路是当主线程第一时间没有从<code>ReadFile</code>中读出预期的字节数后便立即返回<code>FALSE</code>，继续其它操作，另一方面会在后台单开一个线程执行读取操作，真正读取完毕后再返回主线程进行相应的逻辑处理。</p>

<p>下面看详细步骤：</p>

<h4><em>1.句柄设置为可重叠模式</em></h4>

<p>```c
HANDLE h_com = CreateFileA(port,</p>

<pre><code>    GENERIC_READ | GENERIC_WRITE, 
    0,                           
    NULL,                         
    OPEN_EXISTING,                
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED/*可重叠模式*/,
    0);
</code></pre>

<p>```</p>

<h4><em>2.使用可重叠模式进行读取</em></h4>

<p>```c
DWORD dwRes, deRead;
char cRecved[100];
int BytesRead;
OVERLAPPED ol;
ol.Offset = 0;
ol.OffsetHigh = 0;
ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
if (ReadFile(m_hComm, cRecved, len, &amp;BytesRead, &amp;ol)) {</p>

<pre><code>//success!
</code></pre>

<p>} else { //无法第一时间读出数据</p>

<pre><code>dwRes = WaitForSingleObject(ol.hEvent, 5000);//设置5s超时
if (dwRes == WAIT_OBJECT_0) {
    if (!GetOverLappedResult(h_com, &amp;ol, &amp;dwRead, TRUE)) {
        //操作失败，使用GetLastError获取失败信息
    } else {
        //操作成功，数据读出并存入cRecved数组中
    }
}
</code></pre>

<p>}
```</p>

<p>这便是一个可重叠IO的简单示例，可以看出当<code>ReadFile</code>返回<code>FALSE</code>后，我们通过<code>OVERLAPPED</code>结构体获取该操作的事件，并通过<code>WaitForSingleObject</code>来等待异步线程读操作的完成，然后通过<code>GetOverLappedResult</code>验证下最终读取的字节数，便算完成了。</p>

<h3>事件通知</h3>

<p>在一般的通信情景中，大多是有个线程一直等待消息的到来然后进行读取。在开篇的例子中我使用的是简单的睡眠轮询的方式，但在真实地应用场景中这样做显然是不符合实际的，于是便需要使用基于事件通知的方式。</p>

<p>既然是事件监听，那第一步需要做的便是添加事件监听事件，这一步是通过对句柄的设置来完成的：</p>

<p><code>c
SetCommMask(h_com, EV_RXCHAR | EV_TXEMPTY);
</code></p>

<p><code>EV_RXCHAR</code>表示一旦有字节到来便触发事件，<code>EV_TXEMPTY</code>表示缓冲区为空的时候触发事件。</p>

<p>接下来便是对此事件进行监听，并在事件到来时将数据读出：</p>

<p>```c</p>

<pre><code>while (is_running) {
    COMSTAT ComStat;
    DWORD dwRes, dwMask;
    ZeroMemory(myChar, 10);
    OVERLAPPED ol;
    //创建等待事件
    ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    WaitCommEvent(h_com, &amp;dwMask, &amp;ol);
    //对该事件进行等待
    dwRes = WaitForSingleObject(ol.hEvent, 1000000);
    if (dwRes == WAIT_OBJECT_0) {
        if (dwMask &amp; EV_RXCHAR) {
            rol.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            char str[20];
            ZeroMemory(str, 20);
            DWORD dwRead;
            DWORD dwErrors;
            COMSTAT Rcs;
            int i;
            //获取缓冲区字节数量
            ClearCommError(h_com, &amp;dwErrors, &amp;Rcs);
            if (Rcs.cbInQue &gt; 0) {
                if (ReadFile(h_com, &amp;str, Rcs.cbInQue, &amp;dwRead, &amp;rol)) {
                    printf("%d-%d-%d\n", Rcs.cbInQue, dwRead, str[0]);
                }
                else {
                    printf("error\n");
                }
            }
        }
    }
    PurgeComm(h_com, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
}
</code></pre>

<p>```</p>

<p>以上便是事件触发式读取的基本使用方法，需要注意的是，事件触发IO可以搭配重叠IO进行使用，以获得更好的效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX程序制作成WIN Server笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/06/14/unixcheng-xu-zhi-zuo-cheng-win-serverbi-ji/"/>
    <updated>2014-06-14T16:55:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/06/14/unixcheng-xu-zhi-zuo-cheng-win-serverbi-ji</id>
    <content type="html"><![CDATA[<h1>初</h1>

<p>四五月份折腾完聊天服务器后就放了下来开始做个公司的CMS，重拾PHP的感觉还不错。几年不见多了很多框架，随便挑一个用着也很是方便，感觉现在做应用层的开发真是越来越简单了。各种框架工具一应俱到，从UNIX脱离出来重新投入到一键式的开发环境中真有点说不出的幸福。</p>

<p>开始的时候以为编程的世界是个江湖，每个码农都应该朝着绝顶高手的目标不断努力，只有将自己的武功修炼到化境才能算得上功成名就，渐而渐的却发现自己所处的环境跟江湖有不少区别的。也许在自己不知道的层面上还是各种武林高手呼风唤雨，但就现在自己所处的位置却是一个战场无疑。自己的能力与各种框架工具相比就算提升了几倍也是显得那么微不足道。就好比之前写聊天程序时各种尝试，从多进程到多线程，从线程池到多路复用，就自己的能力而言性能是在可观的提升的，心里也有些小得意。直到后面用上了<code>Libevent</code>&hellip;回头看看自己的努力就像天边的浮云，看上去很美而已。</p>

<!--more-->


<p>现在的产品开发正朝着越来越高的层次迈进，对于程序员的素质要求也逐步的降低，很多时候小码农真的像战场上的士兵一样，每人一件标准式的兵器往前冲就是了，真正能主导战场走向的反而是居于幕后激昂指点的PM。</p>

<p><code>C++</code>11出了<code>shared_ptr</code>，苹果手里的<code>OC</code>搭配上<code>ARC</code>还尚嫌不足轰轰烈烈来了个<code>Swift</code>，<code>JS</code>不满足于前端的限制整了套<code>NODEJS</code>，<code>Python</code>的<code>Django</code>，<code>PHP</code>的<code>Codeigniter</code>，大学时所学的操作系统，指针，数据结构已经渐渐地离我们远去，能不能说这是一个最好的时代却也是一个最坏的时代呢？</p>

<h1>缘</h1>

<p>公司现在跑的测试服务器装的是WIN SERVER的系统，没道理为了一个小程序重装系统，所以就开始了踩坑遍地的跨平台旅程。</p>

<h1>足下</h1>

<p>首先需要的是确定使用什么工具进行WIN的编译。以为使用的是Mac做的第一次开发，借助了Eclipse+GCC，所以第一想法也是在WIN下使用这一套环境，进行Eclipse+MinGW相信也可以搞定。</p>

<p>在对GLib进行配置的时候还是相对顺利的，其实在自己心里设想的就是把用到的各种库填好相应的头引用，lib引用就足以使用了。只是后面的历程说明老是把事情往简单想早晚会吃大亏的。</p>

<p>在套Libevent就出现了很多问题，而且因为不知道是不是因为年代比较久远且与现在的潮流脱节，在Google上搜来搜去也就那么几篇文章，我在配的时候出现的<code>PROPC_MESSAGE ERROR</code>根本搜不出所以然来。</p>

<p>于是乎在折腾了N个日子后的一个悲观的整个人都不好了的下午，试想着不如直接用<code>Cygwin</code>算了，顶多从新把东西都编译一遍，但最起码这玩意儿咱做过一遍心里还有底。幸运的是下回来<code>Cygwin</code>刚试用了感觉一切良好的时候下班的时间到了。</p>

<p>回家吃饱饭在图书馆空调的沁脾下逐渐平息了青春的躁动决定还是另谋它法，<code>Cygwin</code>一条路走到黑搞不好被炒了鱿鱼都说不准。由此可见下班及时回家是多么的重要。</p>

<p>第二天回来重新来过开始用起<code>VS</code>来。WIN8配上VS，一切感觉都是那么的美好，阳光透过窗子洒在脚上提醒我到了穿拖鞋上班的季节。</p>

<p>GLib的配置依旧十分顺利，还是卡在了Libevent上。对Libevent的编译十分简单，使用VS自带的<code>nmake</code>可以很轻松的将Libevent的三个lib给编译出来。但在引用的过程中总会出现莫名其妙的错误。开始考虑的是x86与x64导致的问题，但分两种情况编译后问题依然存在。卡了快一天后在网上找到了一个配置好的Demo，运行竟然成功了。通过编译参数的详细对比发现在指定运行库的地方需要调整为<code>/MT</code>的模式，具体的原因参见这篇文章<a href="http://msdn.microsoft.com/zh-cn/library/2kzt1wy3.aspx">/MD、/MT、/LD(使用运行库)</a>，有点踏破铁鞋无觅处，得来全不费功夫的感觉。虽然配置好了但还是有点知其然不知其所以然。</p>

<p>接下来便是再接再厉将<code>mysql</code>的库搭好环境便算彻底搞定了。有时候总觉得事情老是在自己最放心的地方峰回路转，其实说白了还是自己的基本功不扎实，觉得简单并不一定了解到了方方面面，也可能自己并不知道其中的重点难点所在而又继续踩坑。对于<code>mysql</code>的配置这点感触尤其深刻。总觉得相当简单手到擒来，结果还是卡了半天，最后才发现自己选择的是x64的版本与工程版本不匹配，更换后终于拨云见日。</p>

<p>整体环境搭出来后才感觉轻松了不少，觉得这事儿终于算是有些眉目了。虽然WIN下面的socket是自己实现的，但还是跟UNIX的API保持一致的。只需在开始的时候来一句<code>WSAStartup</code>就万事大吉了。其它的便是一些接口的细节修改。在VS下面很多如<code>sprintf</code>，<code>fopen</code>的函数会报不安全的错误，建议修改成<code>sprintf_s</code>，<code>fopen_f</code>，懒得修改的话也可以直接对工程进行配置，忽略这个类型的警告。</p>

<p>最后的成功运行让我心中长出一口恶气，正好是周五的下午，收拾东西踢个靓球。</p>

<h1>峰回</h1>

<p>六月初的时候公司换了新的地点，大了不少不说离着也近感觉还是不错的。新地方上班的第一天便是赶紧在Mac上装个WIN8，之前编译的时候对着项目经理的13寸小电脑佝偻的一个多星期，说什么也不能再受罪了。</p>

<p>这年头来个双系统还是真是方便，纯鼠标操作点几下就搞定了。按完以后面对着WIN8高大上的界面不禁手痒，来几盘CS再方便不过。</p>

<p>这里上班有大食堂可以吃，不用像之前那样叫外卖了，不过之前也没怎么吃外卖，开始是炒了菜带来吃，嫌麻烦改成了面包火腿黄瓜鸡蛋，再后来还是嫌麻烦两片面包夹个鸡蛋足矣。新地方试了几天饭堂发现还是面包鸡蛋吃着爽快，唯一值得留恋的是中午吃饭可以遇到两位管理处的小妹妹，长得都还蛮不错的。</p>

<p>正当觉得要脱离苦海的时候boss要求要把exe做成服务，这样开机可以直接启动更方便。没啥好说的，继续耕耘呗。</p>

<p>开始的时候没什么思路，在网上简单的搜索了下发现有个<code>sc</code>的命令可以直接将exe制作成服务，很是开心。结果制作出来的服务跟不启动不了，再仔细一搜发现关于服务的工程需要调用特定的WIN API才行，觉得心里有点毛，不会又要一阵折腾吧。</p>

<p>在VS下面发现可以直接新建c#的服务工程，但又不能直接用c的代码，想着可以将做的项目做成lib再在里面调用，觉得十分可行。为了验证自己这个想法的可行性，背起书包回家吃饭。</p>

<p>第二天再来的时候果然觉得这个方案不是很靠谱，因为不熟悉WIN API而想方设法绕过去看上去很简单，搞不好又是一坨屎出来。静下来琢磨下过程，直接用c来调用的话应该也不会很难，就当学习呗。</p>

<p>大体的了解了下思路，发现没有自己想象的难，大体就是开始的时候初始化一个叫<code>分配表</code>的结构体，在这个结构体可以定义服务的名字和主调用程序，然后调用一个叫dispatch的函数，大体意思是这个dispatch会把当前进程转换为分配表的进程，然后再通过分配表启动一个新的线程，再用这个线程调用我们的主程序。在这个主程序中我们还需要对当前服务的状态进行不同程度的修改，然后把自己写好的程序放进去就行了。另外还需要写一个<code>Handler</code>来接收这个服务的各种返回状态。</p>

<p>需要注意的是启动的服务无法打印信息，需要搭配日志来使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于C的Socket聊天服务器]]></title>
    <link href="http://sonnewilling.com/blog/2014/05/05/ji-yu-cshi-de-socketliao-tian-fu-wu-qi/"/>
    <updated>2014-05-05T16:26:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/05/05/ji-yu-cshi-de-socketliao-tian-fu-wu-qi</id>
    <content type="html"><![CDATA[<p>前段时间使用C借助libevent，glib实现了一个简单的可以单聊，群聊的服务器，今天因为需求有些改动所以又翻出来改了一下。果然一日不见如隔三秋，虽说是自己写的东西，但基本上已经忘得七七八八了。觉得有必要在这里记录一下，省得以后又悲剧。</p>

<h2>一，工具类</h2>

<h3>1.libunp.a</h3>

<p>用到的第一个库便是它，因为它是《UNIX网络编程》的示例代码的工具库&hellip;开头写的测试程序基本都是照着示例代码改来改去，自然也是用的一样的函数来实现。觉得对于一般的读写和各种包裹函数都是很有用的。具体的不用细说，还是认真翻书来得实在。</p>

<h3>2.GLib</h3>

<h4>GHashTable</h4>

<p>这里基本的数据结构如哈希表之类的使用了GLib来做主角，另外它的GString也很好用，可以很方便的初始化与格式化字符串，个人感觉比C风格的字符串要好用一些。</p>

<p>GLib哈希表支持各种不同的结构，如果觉得<code>int</code>,<code>string</code>不够用可以直接使用指针，对于我来说已经相当足够。</p>

<p><code>c
GHashTable *user_to_bev_map = g_hash_table_new(g_direct_hash,g_direct_equal);
g_hash_table_insert(user_to_bev_map, GINT_TO_POINTER(u_id), GINT_TO_POINTER(bev));
struct bufferevent *bev = g_hash_table_lookup(user_to_bev_map,GINT_TO_POINTER(to_id));
</code></p>

<p><code>g_direct_hash</code>,<code>g_direct_equal</code>代表初始化的类型，详细的介绍如下:</p>

<blockquote><p>Hash values returned by hash_func are used to determine where keys are stored within the GHashTable data structure.</p>

<p>The <code>g_direct_hash()</code>, <code>g_int_hash()</code>, <code>g_int64_hash()</code>, <code>g_double_hash()</code> and <code>g_str_hash()</code> functions are provided for some common types of keys.</p>

<p>If hash_func is NULL, g_direct_hash() is used.</p></blockquote>

<!-- more -->


<h4>GString</h4>

<p>相比于C风格的字符串需要定长初始化，拼接赋值之类的，GString提供的字符串要人性化很多，还内置了长度的属性，可以很方便的调用。</p>

<p><code>c
GString *sql = g_string_sized_new(0);
g_string_printf(sql,"INSERT INTO table (id, type) VALUES (%s, %s);",id,type);
g_string_erase(sql, 0, sql-&gt;len);
g_string_free(sql,1);
</code></p>

<p>还可以很方便的重复使用，但不要忘记最后的释放，关于释放函数的第二个参数是这样说明的：</p>

<blockquote><p>If free_segment is TRUE it also frees the character data. If it&rsquo;s FALSE, the caller gains ownership of the buffer and must free it after use with g_free().</p></blockquote>

<p>还有个常用的函数是<code>g_strsplit</code>，可以对字符进行分割,第三个参数表明需要分出几个来，0的话则一直切分到最后。</p>

<p>```c</p>

<pre><code>gchar **p = g_strsplit(line,",",0);
dispatch_request(source_id-&gt;str, p[3], p[0], p[2], p[1], p[4]);
g_strfreev(p);
</code></pre>

<p>```</p>

<p>当然，关于GLib还有很多有用的东西，用Dash下个文档慢慢翻着看一遍相信会很有收获的。</p>

<h3>3.Mysql</h3>

<p>有服务的地方就有数据库，对于这种简易的小服务，Mysql是必不可少的。</p>

<p>针对Mysql封了三个简单的函数方便调用：</p>

<p>```c</p>

<pre><code>MYSQL *db_connect(char *url, char *user_name, char *pwd, char *table_name) {
    MYSQL *conn_ptr;
    conn_ptr = mysql_init(NULL);
    if (!conn_ptr) {
        printf("mysql_init failed\n");
        return NULL;
    }
    conn_ptr = mysql_real_connect(conn_ptr, url, user_name, pwd, table_name, 0, NULL, 0);
    mysql_set_character_set(conn_ptr,"utf8");
    if (conn_ptr) {
        return conn_ptr;
    } else {
        return NULL;
    }
}
</code></pre>

<p>```</p>

<p>```c</p>

<pre><code>MYSQL_RES *db_query(MYSQL *conn_ptr, char *sql) {
    int res = mysql_query(conn_ptr, sql); //查询语句
    if (res) {
        printf("error:%s\n",mysql_error(conn_ptr));
        return NULL;
    } else {
        MYSQL_RES *res_ptr = mysql_store_result(conn_ptr);              //取出结果集
        printf("affected %lu rows\n",(unsigned long)mysql_affected_rows(conn_ptr));
        return res_ptr;
    }
}
</code></pre>

<p>```</p>

<p>返回的<code>res_ptr</code>需要手动释放：</p>

<p>```c</p>

<pre><code>mysql_free_result(res);
</code></pre>

<p>```
还有一个关闭函数：</p>

<p>```c</p>

<pre><code>void db_close(MYSQL *connfd) {
    mysql_close(connfd);
}
</code></pre>

<p>```
这样，在服务器起来时建立数据库的连接存为全局变量，每次直接拿来用就好了，下面是一个比较典型的使用场景：</p>

<p>```c</p>

<pre><code>GString *sql = g_string_sized_new(0);
g_string_printf(sql,"INSERT INTO table (id, type) VALUES (%s, %s);",id,type);
db_query(conn_ptr, sql-&gt;str);
g_string_erase(sql, 0, sql-&gt;len);
g_string_printf(sql,"SELECT uid FROM table WHERE pid = %s",target_id);
printf("find users sql2:%s\n", sql-&gt;str);
MYSQL_RES *res = db_query(conn_ptr, sql-&gt;str);
MYSQL_ROW sqlrow;
if (res) {
    while((sqlrow = mysql_fetch_row(res)))  {
        long to_id = strtol(sqlrow[0], NULL, 10);
        if (g_hash_table_contains(user_to_bev_map,GINT_TO_POINTER(to_id)) &amp;&amp; strcmp(sqlrow[0],source_id)) {
            struct bufferevent *bev = g_hash_table_lookup(user_to_bev_map,GINT_TO_POINTER(to_id));
            evbuffer_add_printf ((struct evbuffer *)bufferevent_get_output(bev), "%s\n",send_msg-&gt;str);
        }
    }
}
mysql_free_result(res);
g_string_free(sql,1);
g_string_free(send_msg,1);
</code></pre>

<p>```</p>

<h3>4.libevent</h3>

<h4>介绍</h4>

<p>libevent是个好东西，有了它一般的数量级的连接都不在话下了。关于这种大数量的连接是有专门的话题来讨论的-<a href="http://www.kegel.com/c10k.html">C10K</a>。</p>

<p>最开始尝试了多进程多线程，select阻塞之类的方法，最后才找到这里来，也算是按着故事的发展逻辑走了一遍符合剧情尿性吧&hellip;<a href="http://daniel.haxx.se/docs/poll-vs-select.html">这篇文章</a>写得不错，比较有指导性。</p>

<p>关于libevent上手说不上难，狠下心来多读几遍它的<a href="http://www.wangafu.net/~nickm/libevent-book/">Fast portable non-blocking network programming with Libevent</a>弄明白了个大概还是不成问题的。</p>

<p>它的优点是跨平台，可以针对不同的平台的阻塞实现相同的功能。对于我们来说只需要关心event这个东西就好了，至于是UNIX的select，Linux的epoll还是BSD的kqueue那是libevent的事情，它会在底层帮我们选择<a href="http://monkey.org/~provos/libevent/doxygen-2.0.1/">libevent Documentation</a>。</p>

<h4>原理</h4>

<p>原始的socket的连接是我们建立了连接，获得一个套接字，然后对这个套接字进行多路复用的读写。</p>

<p>而现在我们可以使用libevent提供的event将这个套接字包裹起来，针对这个event编写它特定的读写函数。因为libevent是事件驱动的，所以当读写缓冲区达到特定条件时便会自动调用我们事先定义好的函数进行逻辑处理。大大简化了编码人员的工作量，可以让我们将更多的精力集中到逻辑代码的编写上面来（恰恰是最无聊的部分&hellip;），所以这么看来，也算是对程序员傻瓜化了一下吧。</p>

<p>因为对event的读写涉及到缓冲区的东西，需要我们去按字节的读出来，这里libevent也很贴心的又帮我们简化了一下工作。除了event外还提供了<a href="http://www.wangafu.net/~nickm/libevent-book/Ref6_bufferevent.html">bufferevent</a>，看名字便知道这是专门针对读写字符准备的。这是网站上对它的介绍：</p>

<blockquote><p>Most of the time, an application wants to perform some amount of data buffering in addition to just responding to events.</p>

<p>When we want to write data, for example, the usual pattern runs something like:</p>

<ul>
<li><p>Decide that we want to write some data to a connection;</p></li>
<li><p>Put that data in a buffer.Wait for the connection to become writable;</p></li>
<li><p>Write as much of the data as we can;</p></li>
<li><p>Remember how much we wrote, and if we still have more data to write, wait for the connection to become writable again.</p></li>
</ul>


<p>This buffered IO pattern is common enough that Libevent provides a generic mechanism for it. A &ldquo;bufferevent&rdquo; consists of an underlying transport (like a socket), a read buffer, and a write buffer. Instead of regular events, which give callbacks when the underlying transport is ready to be read or written, a bufferevent invokes its user-supplied callbacks when it has read or written enough data.</p></blockquote>

<h4>使用</h4>

<p>我们可以将新建的监听套接字绑定在event上帮我们处理后续的事件：</p>

<p>```c</p>

<pre><code>struct event_base *base;
struct event *listener_event;
serveListen(&amp;listener);
evutil_make_socket_nonblocking(listener);
listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void *)base);
event_add(listener_event, NULL);
event_base_dispatch(base);
</code></pre>

<p>```</p>

<p>当有事件进入时它会主动调用<code>do_accept</code>：</p>

<p>```c
void do_accept(evutil_socket_t listener, short event, void *arg)
{</p>

<pre><code> struct event_base *base = arg;
struct sockaddr_storage ss;
socklen_t slen = sizeof(ss);
int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
if (fd &lt; 0) {
    perror("accept");
} else if (fd &gt; FD_SETSIZE) {
    close(fd);
} else {
    struct bufferevent *bev;
    evutil_make_socket_nonblocking(fd);
    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, readcb, writecb, errorcb, GINT_TO_POINTER(fd));
    bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
    bufferevent_enable(bev, EV_READ|EV_WRITE);
}
</code></pre>

<p>}
```</p>

<p>从上面代码可以看出，我们从<code>accept</code>中接收回一个套接字，并将该套接字绑定在一个<code>bufferevent</code>，设置好相应的读写函数与读写触发的水位线加入到<code>base</code>里便可以从容的等待事件的触发了。</p>

<p>关于水位线，这里也有段详细的描述：</p>

<blockquote><p>Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write &ldquo;watermarks&rdquo; of the bufferevent.</p>

<p>Every bufferevent has four watermarks:</p>

<ul>
<li><code>Read low-water mark</code></li>
</ul>


<p>Whenever a read occurs that leaves the bufferevent’s input buffer at this level or higher, the bufferevent’s read callback is invoked. Defaults to 0, so that every read results in the read callback being invoked.</p>

<ul>
<li><code>Read high-water mark</code></li>
</ul>


<p>If the bufferevent’s input buffer ever gets to this level, the bufferevent stops reading until enough data is drained from the input buffer to take us below it again. Defaults to unlimited, so that we never stop reading because of the size of the input buffer.</p>

<ul>
<li><code>Write low-water mark</code></li>
</ul>


<p>Whenever a write occurs that takes us to this level or below, we invoke the write callback. Defaults to 0, so that a write callback is not invoked unless the output buffer is emptied.</p>

<ul>
<li><code>Write high-water mark</code></li>
</ul>


<p>Not used by a bufferevent directly, this watermark can have special meaning when a bufferevent is used as the underlying transport of another bufferevent. See notes on filtering bufferevents below.</p></blockquote>

<p>细读一遍还是蛮获益匪浅的，大体意思为通过水位线的设置来触发读写的回调函数。</p>

<ul>
<li><p>对于读取水位，有读低水位与高水位，读低水位默认为0，即当buffer里数据量高于0时便会调用读回调，也就是一有数据便会回调，另一方面，当超过读的高水位时，buffer便会停止接受数据，这个值默认被置为<code>unlimited</code>，所以可以理解为永远不会停止接受数据。</p></li>
<li><p>对于写入水位，写的低水位表示当写出数据后buffer里剩余的数据量小于该水位时调用写函数，默认为0，即只有buffer被清空后该函数才会被回调。写的高水位比较特殊，一般情况下没有使用。</p></li>
</ul>


<p>对于水位线的设置是通过下面的函数实现的</p>

<p><code>c
void bufferevent_setwatermark(struct bufferevent *bufev, short events,size_t lowmark, size_t highmark);
ex:bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
</code></p>

<p>在回调函数里这样获取数据：</p>

<p>```c</p>

<pre><code>struct evbuffer *input = bufferevent_get_input(bev);
if ((line = evbuffer_readln(input, &amp;n, EVBUFFER_EOL_LF))) {
    gchar **p;
    p = g_strsplit(line,",",0);
    dispatch_request(u_data-&gt;u_id-&gt;str, p[3], p[0], p[2], p[1], p[4]);
    g_strfreev(p);
}
</code></pre>

<p>```</p>

<p>需要注意的是，提供的<code>evbuffer_readln</code>可以将接受到的一行数据自动去除<code>\n</code>，方便了我们的后期使用。</p>

<h2>二，实现思路</h2>

<p>具体的思路因为暂时在需求上不是很复杂所以比较简单。</p>

<p>首先实现了<code>do_accept</code>函数，阻塞接收请求建立连接的<code>socket</code>，当有新的<code>socket</code>进来后使用<code>bufferevent</code>将其包装好，并设置好它的首次读写回调函数。</p>

<p><code>c
struct bufferevent *bev;
evutil_make_socket_nonblocking(fd);
bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
bufferevent_setcb(bev, readcb, writecb, errorcb, GINT_TO_POINTER(fd));
bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
bufferevent_enable(bev, EV_READ|EV_WRITE);
</code></p>

<p>首次客户端的通信用于标示此次通信的目的，当为登录时，进入<code>reg_client</code>将该用户注册至服务器，并修改其回调函数用于具体的逻辑处理。</p>
]]></content>
  </entry>
  
</feed>
