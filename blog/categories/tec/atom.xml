<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://sonnewilling.com/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://sonnewilling.com/"/>
  <updated>2014-05-04T11:57:32+08:00</updated>
  <id>http://sonnewilling.com/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android USB Host通信]]></title>
    <link href="http://sonnewilling.com/blog/2014/04/30/android-usb-hosttong-xin/"/>
    <updated>2014-04-30T11:18:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/04/30/android-usb-hosttong-xin</id>
    <content type="html"><![CDATA[<h2>开了个头</h2>

<p>一部Android手机加上一块Arduino的板子通过USB通信可以实现很多有趣的东西。</p>

<p>2011年Google推出Android开放配件协议AOA及配件开发工具包ADK提供了Android USB或蓝牙进行通信的API，为基于Android系统的智能设备控制外设提供了条件。利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备 <a href="http://www.chinaaet.com/article/216691">原文</a>。</p>

<!-- more -->


<p>想来这便是Android的魅力所在，开源的Linux系统给了任何人实现自己的梦想的可能。无需再依靠大的厂商提供的一套套完整的服务。仅仅通过自己的想象力配以几块平淡无奇的板子，便能实现一些之前看起来很高大上的东西。</p>

<h2>利其器</h2>

<p>1.Android-<a href="http://developer.android.com/sdk/index.html">ADT</a></p>

<p>Android的简单开发依赖于工具包SDK和开发工具IDE的使用。Google为我们提供的ADT打包了完善的开发工具：</p>

<blockquote><p>Eclipse + ADT plugin</p>

<p>Android SDK Tools</p>

<p>Android Platform-tools</p>

<p>The latest Android platform</p>

<p>The latest Android system image for the emulator</p></blockquote>

<p>这里还不得不提的是一个关于Android模拟器的问题。用过eclipse的都知道，上面自带的模拟器速度奇慢，尤其当适应了iPhone开发后对其更是不能忍受。这里有一篇文章便是专门讲解了下为毛Android的模拟器这么慢-<a href="http://stackoverflow.com/questions/1584617/simulator-or-emulator-what-is-the-difference">Simulator or Emulator</a>。</p>

<p>然后便发现了这个神器-<a href="http://www.genymotion.com/">Genymotion</a>，感觉这玩意儿比苹果的模拟器还快。</p>

<p>2.<a href="http://www.arduino.cc/">Arduino</a></p>

<p>这个板子还是蛮便宜又好用的，官网的文档也全，基本跟着读一遍就知道大体的开发的流程了，提供的IDE有点坑，只能设为9号字体，倒是可以调大，调大的话光标根本对不上&hellip;</p>

<p><img src="/images/tec/androidusb/arduino.png" alt="image" /></p>

<p>示例的代码做了个简单的读数据的功能，每次读一行然后原样返回。</p>

<p>开头的setup那里设置了<a href="http://en.wikipedia.org/wiki/Baud">波特率</a>，大体上波特率跟每秒发送的信息量有关。手上的这块板子经过简单的测试，有如下数据：</p>

<blockquote><p>波特率为9600时，每次可以携带129个字节，间隔极限在150ms</p>

<p>波特率为14400时，每次可以携带191个字节，间隔极限在260ms</p></blockquote>

<p>个人推测大概越好的板子每次能携带的信息量越大且时间间隔越短吧，即所谓的可以支持很高的波特率。</p>

<p>有了上面这两套东西基本上就可以开始USB通信了。</p>

<h2>幕前</h2>

<p>关于详细的实现Google的教程上有个快速简易的介绍，一般跟着做是可以实现效果的-<a href="http://developer.android.com/guide/topics/connectivity/usb/index.html">USB Host and Accessory</a>。稍微了解过Android开发的看着玩意儿没啥问题。基本上就是在<code>manifest</code>里对指定的activity配置下权限就妥了，它还提供了一个<code>device_filter</code>的xml文件，可以过滤指定的USB设备。</p>

<p>因为要在Andorid上做开发然后测试与Arduino，所以免不了要先往Android上写程序再让这俩东西连接，老是这样往复的在几台设备间插拔效率太低，Google提供给我们的解决方案是让Android通过Wifi连电脑，然后Android与Arduino一直连着线就妥了。</p>

<p>照着试了几遍，别人的电脑一连就妥，我的死活不行，也不知是不是苹果机的缘故。无奈实在没有插来插去的兴趣，所以又研究了下Genymotion，因为它是依托在VirtualBox上的，总觉得可以一搞。</p>

<p>多次尝试后发现，可以先将Arduino板插上电脑，如下图会出现这个设备，添加虚拟机对它的过滤，这之后把板子拔下来再插回去的话虚拟机也即Android模拟器便可以接收到Arduino板子的信号了。想要对板子连电脑烧程序的话，则反过来，先取消对板子的过滤，插拔一次便连上电脑了。</p>

<p><img src="/images/tec/androidusb/usbbox.png" alt="image" /></p>

<p>具体的实现大体分为四步：<a href="http://developer.android.com/guide/topics/connectivity/usb/index.html">USB Host and Accessory</a></p>

<h4>一，Obtaining permission to communicate with a device</h4>

<p>先实例化一个<code>UsbManager</code>，通过它来获取USB连接的权限。</p>

<p>```java
UsbManager mUsbManager = (UsbManager) getSystemService(Context.USB_SERVICE);
private static final String ACTION_USB_PERMISSION =</p>

<pre><code>"com.android.example.USB_PERMISSION";
</code></pre>

<p>mPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);
IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
registerReceiver(mUsbReceiver, filter);
UsbDevice device;
mUsbManager.requestPermission(device, mPermissionIntent);
<code>
权限获取：
</code>java
private static final String ACTION_USB_PERMISSION =</p>

<pre><code>"com.android.example.USB_PERMISSION";
</code></pre>

<p>private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (ACTION_USB_PERMISSION.equals(action)) {
        synchronized (this) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                if(device != null){
                  //call method to set up device communication
               }
            } 
            else {
                Log.d(TAG, "permission denied for device " + device);
            }
        }
    }
}
</code></pre>

<p>};
```</p>

<h4>二，Enumerating devices</h4>

<p>```java
HashMap&lt;String, UsbDevice> deviceList = manager.getDeviceList();
Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();
while(deviceIterator.hasNext()){</p>

<pre><code>UsbDevice device = deviceIterator.next()
//your code
</code></pre>

<p>}
```</p>

<h4>三，Communicating with a device</h4>

<p><code>java
private Byte[] bytes
private static int TIMEOUT = 0;
private boolean forceClaim = true;
UsbInterface intf = device.getInterface(0);
UsbEndpoint endpoint = intf.getEndpoint(0);
UsbDeviceConnection connection = mUsbManager.openDevice(device);
connection.claimInterface(intf, forceClaim);
connection.bulkTransfer(endpoint, bytes, bytes.length, TIMEOUT); //do in another thread
</code></p>

<h4>四，Terminating communication with a device</h4>

<p>```java
BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction(); 
  if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
        UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
        if (device != null) {
            // call your method that cleans up and closes communication with the device
        }
    }
}
</code></pre>

<p>};
```</p>

<p>需要注意的是两者间的通讯都是以Byte形式完成的，所以作为在接收与发送的时候需要注意相关的转码工作，而且我这边实现的是一行行的读取，所以发送的时候会隐式地拼接上<code>\n</code>。</p>

<p>发送时的转码：</p>

<p>```java
private String changeEscapeSequence(String in) {</p>

<pre><code>String out = new String();
try {
    out = unescapeJava(in);
} catch (IOException e) {
    return "";
}
out = out + "\n";
return out;
</code></pre>

<p>} <br/>
private String unescapeJava(String str) throws IOException {</p>

<pre><code> if (str == null) {
     return "";
 }
 int sz = str.length();
 StringBuffer unicode = new StringBuffer(4);
 StringBuilder strout = new StringBuilder();
 boolean hadSlash = false;
 boolean inUnicode = false;
 for (int i = 0; i &lt; sz; i++) {
     char ch = str.charAt(i);
     if (inUnicode) {
         // if in unicode, then we're reading unicode
         // values in somehow
         unicode.append(ch);
         if (unicode.length() == 4) {
             // unicode now contains the four hex digits
             // which represents our unicode character
             try {
                 int value = Integer.parseInt(unicode.toString(), 16);
                 strout.append((char) value);
                 unicode.setLength(0);
                 inUnicode = false;
                 hadSlash = false;
             } catch (NumberFormatException nfe) {
                 // throw new NestableRuntimeException("Unable to parse unicode value: " + unicode, nfe);
                 throw new IOException("Unable to parse unicode value: " + unicode, nfe);
             }
         }
         continue;
     }
     if (hadSlash) {
         // handle an escaped value
         hadSlash = false;
         switch (ch) {
             case '\\':
                 strout.append('\\');
                 break;
             case '\'':
                 strout.append('\'');
                 break;
             case '\"':
                 strout.append('"');
                 break;
             case 'r':
                 strout.append('\r');
                 break;
             case 'f':
                 strout.append('\f');
                 break;
             case 't':
                 strout.append('\t');
                 break;
             case 'n':
                 strout.append('\n');
                 break;
             case 'b':
                 strout.append('\b');
                 break;
             case 'u':
                 {
                     // uh-oh, we're in unicode country....
                     inUnicode = true;
                     break;
                 }
             default :
                 strout.append(ch);
                 break;
         }
         continue;
     } else if (ch == '\\') {
         hadSlash = true;
         continue;
     }
     strout.append(ch);
 }
 if (hadSlash) {
     // then we're in the weird case of a \ at the end of the
     // string, let's output it anyway.
     strout.append('\\');
 }
 return new String(strout.toString());
</code></pre>

<p>}
```</p>

<p>接收时的转码：</p>

<p>```java
void setSerialDataToTextView(int disp, byte[] rbuf, int len, String sCr, String sLf) {</p>

<pre><code>for (int i = 0; i &lt; len; ++i) {
    mText.append((char) rbuf[i]);
}
</code></pre>

<p>}
```</p>

<h2>正主</h2>

<p>其实最后在各种测试的时候没有用Google的这个原始流程，在网上发现了一份比较完整的USB通讯示例流程-<a href="https://github.com/ksksue/Android-USB-Serial-Monitor-Lite">Android-USB-Serial-Monitor-Lite</a>，直接用它提供的各种工具做的测试&hellip;我的测试代码在这里<a href="https://github.com/wanax/android_usb_test">android_usb_test</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下的Socket通信-TCP/IP基本概念]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-tcp-slash-ipji-ben-gai-nian/"/>
    <updated>2014-03-20T18:44:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-tcp-slash-ipji-ben-gai-nian</id>
    <content type="html"><![CDATA[<h2>总览</h2>

<blockquote><p>All problems in computer science can be solved by another level of indirection</p></blockquote>

<p>觉得这句话对TCP的分层也很适用。</p>

<p>对TCP/IP协议来说，大体分为五层，</p>

<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ol>


<p>应用层我们接触的比较多，流行的如HTTP，FTP之类都算，像我在大学里做的PHP开发时基本对HTTP发包没有任何概念，照着教程开eclipse，apache，在浏览器里敲个<code>locahost:8080</code>出来个猫的图案就很开心了。再建个index，上面写句“未满18周岁禁止进入”，就有种天下在手的感觉。</p>

<!--more-->


<p>后来做java网站，用到了HttpClient，逐渐对HTTP的抓包发包有了简单地了解。通过这玩意儿就可以做到绕过网页填写，直接后台模拟网页提交表单，那些抢票软件大体上就是这个思路。</p>

<p>再往下便是闻名已久的传输层（TCP,UPD,SCTP etc.）与网络层(IPv4,IPv6 etc.)了。</p>

<h2>网络的划分</h2>

<p><img src="/images/tec/Socket/hierarchy.png" alt="image" /></p>

<p>通过上图可以很直观的看到应用层的实体数据经过层层的包装最终封印在了链路层中在物理层中进行传输。其中每一层实体间交换的单位信息称为<em>协议数据单元(protocol data unit,PDU)</em>。每层的PDU作为下层的<em>数据服务单元（service data unit,SDU）</em>传递给下层，并由下层间接完成本层的PDU交换。</p>

<p>为了避免诸如TCP的PDU，IP的PDU这类很不简洁的称呼，国际上给每层的PDU都另外取了自己的名字。传输层的称为<em>segment（分节）</em>，网络层的称为<em>IP datagram（IP数据报）</em>，链路层的称为<em>frame（帧）</em></p>

<p>而关于层与层间的打包封印也有它们不得不说的故事，那就是分片。简单的说如果本层PDU的大小超过紧邻下层的最大SDU限制，那么本层还要事先把PDU划分成若干个合适的片段让下层分开载送，再在相反方向把这些片段重组成PDU。同一层内SDU作为PDU的净荷（payload）字段出现，因此可以说上层PDU作为本层的SDU字段由本层PDU承载。如上图所示每层PDU除用于承载紧邻上层的PDU（即承载数据外），也用于承载本层协议内部通讯所需的控制信息（各种header）。</p>

<p>当然这只是个初步的说法，下面会针对传输层与网络层展开具体一下的学习。</p>

<h3>1.传输层</h3>

<p>一说传输层TCP，讲不通三次握手连接，四次握手关闭都不好意思出来混。</p>

<h4>先看连接图示：</h4>

<p><img src="/images/tec/Socket/connect.JPG" alt="image" /></p>

<p>图中有类似于SYN，ACK的标记量，结合上一章的内容，其实这也是TCP分节的一种。分节除了用于承载数据外，也用于建立连接（SYN分节），终止连接（FIN分节），中止连接（RST分节），确认数据接收（ACK分节），刷送待发数据（PSH分节）和携带紧急数据指针（URG分节），而且这些功能（包括承载数据）可以灵活组合。</p>

<p>也就是说在建立连接的初期，由Socket自带的函数为我们发送分节握手沟通，握手连接建立后，则由用户自行组织分节信息进行通信。</p>

<p>关于上图的握手过程可以简单复述一下：</p>

<ol>
<li>服务器必须准备好接受外来的连接，这通常通过调用<code>socket</code>,<code>bind</code>,<code>listen</code>这三个函数来完成，称之为<em>被动打开（passive open）</em>。</li>
<li>客户通过调用<code>connect</code>发起<em>主动打开（active open）</em>。这导致客户TCP发送一个SYN（同步）分节，它告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部，一个TCP首部及可能有的TCP选项。</li>
<li>服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。</li>
<li>客户必须确认服务器的SYN。</li>
</ol>


<p>上述过程中出现了<em>SYN_SENT</em>之类的字样，它们代表了套接字的状态。在<code>socket</code>函数初始化后套接字的状态为<em>CLOSED</em>，<code>connect</code>函数导致当前套接字从<em>CLOSED</em>状态转移到<em>SYN_SENT</em>状态，若成功则在转移到<em>ESTABLISHED</em>状态。<em>若<code>connect</code>失败则该套接字不再可用，必须关闭，不可以对这样的套接字再次调用<code>connect</code>函数，而是在每次失败后，必须<code>close</code>当前的套接字描述符并重新调用<code>socket</code></em>。</p>

<h4>再来个关闭图示：</h4>

<p><img src="/images/tec/Socket/close.JPG" alt="image" /></p>

<ol>
<li>某个应用进程首先调用<code>close</code>，称该端执行<em>主动关闭（active close）</em>，该端的TCP于是发送一个FIN终止分节，表示数据发送完毕。</li>
<li>接收到这个FIN对端执行<em>被动关闭（passive close）</em>。这个FIN由TCP确认。它的接收也作为一个<em>文件结束符（end-of-file）</em>传递给接收端应用进程（放在已排队等候该应用进程接收的任何其它数据之后），因为FIN的接收意味着接收端应用进程在相应连接上再无额外的数据可接收。</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用<code>close</code>关闭它的套接字。这导致了它的TCP也发送一个FIN。</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li>
</ol>


<p>在握手连接的过程中，套接字通过发送SYN（建立连接分节）经历了COLSE，SYN_SENT，ESTABLISHED等状态，达到了可以通信的目的。而在四次关闭握手连接中，套接字也要经历几种状态，达到真正关闭的目的，<em>需要注意的是，因为TCP是全双工的，所以正常情况下的关闭需要经过双方的确认才可以完全关闭，这就需要通信两端都分别发送自己的FIN信号，且回应对方的FIN，因此理论上关闭握手需要四次，每个套接字各两次。</em></p>

<ol>
<li>FIN_WAIT_1：<em>主动方</em>套接字在ESTABLISHED状态正常通信时，它想主动关闭连接，于是向对方发送了FIN报文，此时该套接字即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。</li>
<li>FIN_WAIT_2：<em>主动方</em>通俗的讲便是我已经完成任务并且告知对端完成我方的关闭，然后我在等你发送你的FIN，要是你还有什么话说那赶紧，我这边该说的都说完了&hellip;</li>
<li>CLOSE_WAIT：<em>被动方</em>对应的是FIN_WAIT_2状态，便是在正常ESTABLISHED状态下收到了对端的FIN信号，但我还有活没做完，需要搞定后才往你那儿发送FIN终止信号，此时的状态便是CLOSE_WAIT。</li>
<li>LAST_ACK：<em>被动方</em>被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。</li>
<li>TIME_WAIT：<em>主动方</em>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
</ol>


<p>在这些状态中，比较不好理解的是TIME_WAIT状态。我们看到执行主动关闭的一方经历了这个状态。该端点停留在这个状态的持续时间是<em>最长分节生命期（maximum segment lifetime，MSL）</em>的两倍，有时候称之为2MSL。</p>

<p>任何TCP实现都必须为MSL选择一个值。其时间在1分钟到4分钟之间。MSL是任何IP数据报能够在因特网中存活的最长时间。因为每个数据报含有一个称为<em>跳限（hop limit）</em>的8位字段，它的最大值为255.一般上假设：</p>

<blockquote><p>具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒。</p></blockquote>

<p>所以TIME_WAIT状态有两个存在的理由，</p>

<ol>
<li>可靠地实现TCP全双工连接的终止。TCP连接在主动关闭方发送的最后一个ACK(FIN)，有可能丢失，这时被动方会重新发FIN, 如果这时主动方处于CLOSED状态 ，就会响应RST而不是ACK。所以主动方要处于TIME_WAIT状态，而不能是CLOSED。</li>
<li>允许老的重复分节在网络中消逝，因为经过2MSL，上一次连接中所有的重复包都会消失。</li>
</ol>


<p>最后放一张TCP中套接字的状态大图~</p>

<p><img src="/images/tec/Socket/status.png" alt="image" /></p>

<h3>2.网络层</h3>

<p>因为主体是使用TCP的Socket进行编程，这里对网络层的具体细节就不做探讨了。但关于网络层还会牵扯到分片的问题，这里需要重视起来。</p>

<p>在TCP传输层中，发送端TCP把来自应用进程的字节流数据（即由应用进程通过一次次输出操作写出到发送端TCP套接字中的数据）按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据既可能是发送端应用进程单次输出操作的结果，也可能是数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于可在连接建立阶段由对端通告的<em>最大分节大小（maximum segment size,MSS）</em>以及<em>外出接口的最大传输单元（maximum transmission unit,MTU）</em>或<em>外出路径的路径MTU</em>。</p>

<p>MSS的目的是告诉对端其重组缓冲区大小的实际值，从而试图避免分片。MSS经常设置成MTU减去IP和TCP首部的固定长度。</p>

<p>网络层实体间交换的PDU称为IP数据报（IP datagram）,其长度有限：IPv4数据报最大长度65535字节，IPv6S数据报最大65575.发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中发送。链路层实体间交换的PDU称为帧（frame），其长度取决于具体的接口。IP数据报由IP首部和所承载的传输层数据（即网络层的SDU）构成。过长的IP数据报无法封装在单个帧中，需要先对其SDU进行分片（fragmentation），再把分成的各个片段（fragment）冠以新的IP首部封装到多个帧中。在一个IP数据报从源端到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中，而其逆操作即重组（reassembly）一般只发生在目的端。</p>

<p>TCP/IP协议族为提高效率会尽可能避免IP的分片/重组操作：TCP根据MSS和MTU限定每个分节的大小，且在途中尽量避免分片操作。不论是否分片都由IP作为链路层的SDU传入链路层，并由链路层封装在帧中数据称为分组（packet，俗称包）。可见一个分组既可能是一个完整地IP数据报，也可能是某个IP数据报的SDU的一个片段被冠以新的IP首部后的结果。</p>

<h2>下一步</h2>

<p>总结了基本套接字函数的使用与TCP/IP的简单概念，下一步将会着手编写一套客户/服务器的通信演示Demo，会考虑实现线程池来提高并发效率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下的Socket通信-Socket的连接]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-Socket-de-lian-jie/"/>
    <updated>2014-03-20T15:55:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-Socket-de-lian-jie</id>
    <content type="html"><![CDATA[<h2>一.关于Socket</h2>

<p>如我，刚见这个名词的时候不知所云，因为起点就没找对，首先要在基于对UNIX有所了解的情况下才利于开展工作，便是“一切皆文件”。</p>

<p>在UNIX下，一般的文件可以通过open打开，并返回一个小整数作为标记，后续的操作便是针对这个小整数进行读写。这个小整数被称作<em>描述符</em>，描述符只是引用file的proc结构中一个数组的某个元素的下标而已，它可以代表该文件，但并不是文件本身，我们通过它来与文件建立联系，方便操作。</p>

<p>以此为前提，Socket便是一种特殊的文件，通过<em>socket</em>函数可以创建一个套接字（特殊的文件），它也返回给我们一个小整数，以后所有的函数调用就用该描述符来标示这个套接字。</p>

<p>在UNIX下文件的种类有很多，打开与使用的方式虽然遵循着一定的模式，但也不尽相同。比如想打开一个文本文件需要借助open函数，而且在打开的时候需要告诉open函数该文本的路径位置，以明确打开的目标。</p>

<!--more-->


<p>Socket的打开也与之相似，因为它一定程度上可以理解为是一个联网通信的文件，所以如果想要明确打开的目标，肯定不能传送一个本地路径，而要与之相符地传送一个目标IP地址。当然这只是简单的比喻，Socket的建立要比文件要复杂一些，IP地址的设置只是打开过程的一个步骤，因为涉及到了网络的缘故，还需要设置很多参数。毕竟文本文件是自己的，打开的标准关上门来自己做主，怎么方便都好商量。而Socket则不一样，既然是在各种主机间通信，且走的路线均不一样，这就牵扯到了各种配置。</p>

<h2>二.TCP下IPv4的Socket连接</h2>

<h3>1.socket</h3>

<p>让我们来看Socket建立的第一步的函数</p>

<p><code>c
int socket(int family, int type, int protocol);
</code></p>

<p>明显的，单是第一步就比open函数多参数。</p>

<p>其中family参数指明协议族，type指明套接字类型，protocol为某个协议的常值类型，或者设为0。</p>

<h4>socket函数的type常值</h4>

<table>
<thead>
<tr>
<th></th>
<th>       type          </th>
<th>        说明         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> SOCK_STREAM    </td>
<td>    字节流套接字   </td>
</tr>
<tr>
<td></td>
<td> SOCK_DGRAM     </td>
<td>     数据报套接字  </td>
</tr>
<tr>
<td></td>
<td>SOCK_SEQPACKET  </td>
<td>    有序分组套接字 </td>
</tr>
<tr>
<td></td>
<td>   SOCK_RAW     </td>
<td>     原始套接字   </td>
</tr>
</tbody>
</table>


<h4>socket函数protocol常值</h4>

<table>
<thead>
<tr>
<th></th>
<th>    protocol     </th>
<th>        说明         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> IPPROTO_TCP    </td>
<td>    TCP传输协议   </td>
</tr>
<tr>
<td></td>
<td> IPPROTO_UDP    </td>
<td>     UDP传输协议  </td>
</tr>
<tr>
<td></td>
<td> IPPROTO_SCTP   </td>
<td>    SCTP传输协议  </td>
</tr>
</tbody>
</table>


<p>所以如果</p>

<p><code>c
sockfd = socket(AF_INET, SOCK_STREAM, 0);
</code></p>

<p>则表示socket函数创建一个网际（AF_INET）字节流（SOCK_STREAM）套接字。</p>

<h3>2.connect</h3>

<p>第一步的socket函数只是把一些基本的参数设置好并返回了一个描述符，就像安好了电话，但其实并没有开始扯线连接，connect帮我们搞定这一步。</p>

<p><code>c
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
</code></p>

<p>socket是由socket返回的套接字描述符，第二个，第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。套接字地址结构必须含有服务器的IP地址和端口号。</p>

<p>关于sockaddr的结构大体如下：</p>

<p>```c
struct sockaddr_in {</p>

<pre><code>sa_family_t    sin_family; /* address family: AF_INET */
in_port_t      sin_port;   /* port in network byte order */
struct in_addr sin_addr;   /* internet address */
</code></pre>

<p>};
```</p>

<p>对此结构一般的设置方法如下</p>

<p><code>c
bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons(13);//服务器端口
inet_pton(AF_INET, "192.168.105.105", &amp;servaddr.sin_addr);//服务器地址
</code></p>

<p>因为具体的连接动作是使用网络字节序的，并不是我们所见到的诸如<code>192.168.105.105:13</code>之类的表达，所以需要htons与inet_pton进行相应的转换。<em>htons()主机到网络短整数，转换二进制端口号</em>，地址转换函数在地址的文本表达式和它们存放在套接字地址结构中的二进制值之间转换。</p>

<p>如果是写一个客户端的请求程序，那么前两个函数就可以满足要求建立了套接字，下一步的动作便是针对该套接字返回的描述符进行相应的读写便可以了。但要是想做一个服务器端的进程具有监听功能的话则还需要另外下面这三个函数。</p>

<h3>3.bind，listen，accept</h3>

<blockquote><p>打个简单的比喻，建立TCP连接就好比一个电话系统。socket函数等同于有电话可用。connect要求我们知道对方的电话号码并拨打它。bind函数是在告诉别人你的电话号码，这样他们可以呼叫你。listen是打开电话振铃，这样当有个外来呼叫到来时，你可以听到。accept则相当于接电话。</p></blockquote>

<p>对于服务器端的socket addr的初始化如下</p>

<p><code>c
bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sin_family      = AF_INET;
servaddr.sin_port        = htons(SERV_PORT);
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
</code></p>

<p>它区别于客户端的套接字初始化在于第四行，并没有指定目标IP地址，代之的是一个INADDR_ANY的宏，它可以表示我接收来自任何地址的请求。
如果想要真正实现这一目的，我们需要调用bind来告知UNIX系统我这个套接字将被用来接收信号：</p>

<p><code>c
int bind(int sockfd, const stuct sockaddr *myaddr, socklen_t addrlen);
</code></p>

<p>继而取消电话的静音状态：</p>

<p><code>c
int listen(int sockfd, int backlog);
</code></p>

<p>此函数通常应该在调用socket和bind这两个函数之后，并在调用accept之前调用。</p>

<p>关于backlog，是一个设置未完成连接队列与已完成连接队列的参数，这里暂不做细致的探讨了。</p>

<p>最后一步，我们的进程将阻塞于accept的调用中。accept函数由TCP服务器调用，用于从已完成的连接队列头返回下一个已完成连接。关于阻塞函数，看下面这段的讲解：</p>

<blockquote><p>永远阻塞的系统调用是指调用有可能永远无法返回，也可称为慢系统调用（slow system call），多数网络支持函数都属于这一种（accept）。适用于慢系统调用的基本规则是，当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。</p></blockquote>

<p>对于此类错误我们可以通过以下函数进行绕过，</p>

<p>```c
for ( ; ; ) {</p>

<pre><code>    clilen = sizeof(cliaddr);
    if ( (connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) {
        if (errno == EINTR)
            continue;       /* back to for() */
        else
            err_sys("accept error");
    }
}
</code></pre>

<p>```</p>

<p>以上便是一个服务器端的监听套接字的建立过程。</p>

<h3>4.close，shutdown</h3>

<p>有开就有关，关于套接字的关闭我们一般使用close与shutdown来进行控制。</p>

<p>正如我们前面所述，我们通过描述符对套接字进行操作，描述符不过是对file的一个下标而已，如果有多个进程同时使用描述符，则均可以表示为对此file的一个引用。初始的引用值为1，每当调用fork以派生子进程或对打开操作返回的描述符（或其复制品）调用dup以复制描述符时，该file结构的引用计数就递增。相应的close()使相应描述符的引用计数减1，当该描述符引用计数为0时则引发正常TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自的对端确认。如想确实在某个TCP连接上发送FIN，可以改用shutdown。</p>

<h3>5.最后无图无真相:</h3>

<p><img src="/images/tec/Socket/funtime.jpg" alt="image" /></p>

<h2>下一步</h2>

<p>这部分具体介绍了Socket的基本概念与一个客户端和服务端的套接字是怎样一步步建立起来的。但文章中也出现了一些诸如FIN之类的关键字并没有进行详细的解释，在下一章，我会对TCP/IP的一些基本概念进行解释。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GLib编译笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/13/glibbian-yi-bi-ji/"/>
    <updated>2014-03-13T15:38:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/13/glibbian-yi-bi-ji</id>
    <content type="html"><![CDATA[<h3>缘起</h3>

<p>最近做的一个项目是使用C写的，随着项目的深入发现需要通过不同的数据结构来完成需求，自己简单地去编写已经不能满足要求且在健壮性方面也存在着隐患，于是就琢磨着在网上找找看看有没有什么现成的C工具包来用，就这样，发现了GLib。</p>

<p>先来看下维基上的介绍：</p>

<blockquote><p>GLib是一个跨平台的、用C语言编写的库，起初是GTK+的一部分，但到了GTK+第二版，开发者决定把跟图形界面无关的代码分开，这些代码于是就组装成了GLib。GLib提供了多种高级的数据结构，如内存块、双向和单向链表、哈希表、动态字符串等。</p></blockquote>

<p>感觉功能刚好满足需要，类似于C++中的STL，果断搞起。</p>

<!--more-->


<h3>1.下载</h3>

<p>从网上搜索GLib找到了这里<a href="http://www.linuxfromscratch.org/blfs/view/svn/general/glib2.html">Linux From Scratch</a>，下载它的压缩包。</p>

<p>这个网站也把具体的编译安装方式写得很明白。</p>

<blockquote><h3>GLib Dependencies</h3>

<h4>Required</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/libffi.html">libffi-3.0.13</a> and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/python2.html">Python-2.7.6</a></p>

<h4>Recommended</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/pcre.html">PCRE-8.34</a>(built with Unicode properties)</p>

<h4>Optional</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/postlfs/attr.html">attr-2.4.47</a>, <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/dbus.html">D-Bus-1.8.0</a> (required to run the tests), and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/gtk-doc.html">GTK-Doc-1.20</a></p>

<h4>Additional Runtime Dependencies</h4>

<p>Quoted directly from the INSTALL file: “Some of the mimetype-related functionality in GIO requires the update-mime-database and update-desktop-database utilities”, which are part of <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/shared-mime-info.html">shared-mime-info-1.2</a> and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/desktop-file-utils.html">desktop-file-utils-0.22</a>, respectively.</p></blockquote>

<p>就是说想要安装GLib的话最起码得先把Required和Recommended里的东西装完才行。</p>

<h3>2.编译</h3>

<p>安装环境配好后就可以正式安装了，顺着那个网页往下走就能看到具体的方法：</p>

<p><code>c
./configure --prefix=/usr --with-pcre=system &amp;&amp; make
</code>
再然后</p>

<p><code>c
sudo make install
</code>
GLib在gcc里的使用是借助了一个叫pkg-configure的工具，这玩意儿的作用这位哥儿们说得很详细了，看他的介绍吧：<a href="http://www.chenjunlu.com/2011/03/understanding-pkg-config-tool/">理解 pkg-config 工具</a></p>

<p>其实定位到<code>/usr/lib/pkgconfigure</code>后会发现它里面放了很多你自己安装的库的.pc的配置文件，用vim随便打开一个发现它的内容是这样的：</p>

<p><code>c
   prefix=/usr
   exec_prefix=${prefix}
   libdir=${exec_prefix}/lib
   includedir=${prefix}/include
&amp;
   glib_genmarshal=glib-genmarshal
   gobject_query=gobject-query
   glib_mkenums=glib-mkenums
&amp;
   Name: GLib
   Description: C Utility Library
   Version: 2.38.2
   Requires.private: libpcre
   Libs: -L${libdir} -lglib-2.0 -lintl
   Libs.private:   -lpcre  -lintl  -liconv
   Cflags: -I${includedir}/glib-2.0 -I${libdir}/glib-2.0/include
</code>
看一下就明白了，基本上就是帮你写了一堆编译选项，免得到时候自己编译的时候要敲一坨，而且在不同的电脑上编译的时候也可以动态的调整路径，不用一遍遍的去改Makefile。</p>

<p>比如说自己编译一个使用了GLib的文件，可以这样敲：</p>

<p><code>c
gcc `pkg-config --cflags --libs glib-2.0`  hello.c -o hello
</code></p>

<p>–cflags 参数可以给出在编译时所需要的选项，而 –libs 参数可以给出连接时的选项。</p>

<p>当然如果不使用pkg-configure的话也可以类似这样子：</p>

<p><code>c
gcc  -L/usr/lib -I/usr/lib/glib/include/glib-2.0 hello.c -o hello -liconv -lresolv -lpcre -lintl -lglib-2.0
</code>
所以基本上还是简化了很多操作的。</p>

<h3>3.测试使用</h3>

<p>测试一下GLib中哈希表的使用吧：</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;glib.h></h1>

<p>int main(){</p>

<pre><code>    printf("Glib version: %u.%u.%u\n\n",glib_major_version,glib_minor_version,glib_micro_version);
</code></pre>

<p>&amp;</p>

<pre><code>    GHashTable* hash = g_hash_table_new(g_str_hash, g_str_equal);
    g_hash_table_insert(hash, "Virginia", "Richmond");
    g_hash_table_insert(hash, "Texas", "Austin");
    g_hash_table_insert(hash, "Ohio", "Columbus");
</code></pre>

<p>&amp;</p>

<pre><code>    printf("There are %d keys in the hash\n",g_hash_table_size(hash));
    printf("The capital of Texas is %s\n",g_hash_table_lookup(hash, "Texas"));
    gboolean found = g_hash_table_remove(hash, "Virginia");
    printf("The value 'Virginia' was %sfound and removed\n", found ? "" : "not ");
</code></pre>

<p>&amp;</p>

<pre><code>    g_hash_table_destroy(hash);
    return 0;
</code></pre>

<p>}
```
可以打印如下信息：</p>

<blockquote><p>Glib version: 2.38.2</p>

<p>There are 3 keys in the hash</p>

<p>The capital of Texas is Austin</p>

<p>The value &lsquo;Virginia&rsquo; was found and removed</p></blockquote>

<h3>4.搭配Eclipse</h3>

<p>嫌敲命令行麻烦的话也可以配到Eclipse上用。现在在Eclipse上有了pkg-configure的插件，可以对GLib直接勾选使用，但我安装后没有起到效果，不知道哪里出了问题<a href="https://code.google.com/p/pkg-config-support-for-eclipse-cdt/">pkg-config-support-for-eclipse-cdt</a>。但反正原理已经知道了，索性自己配一下也就妥了。</p>

<p>选中工程，在Project里找到Properties进入到下图的界面：</p>

<p><img src="/images/tec/GLib/eclipsecon.png" alt="image" /></p>

<p>在Libraries里配置GLib库的位置和名字，在Includes里配置GLib头文件的位置，我的头文件在这里</p>

<p><code>c
/usr/include/glib-2.0
</code>
其实按照教程正常安装的话基本上都会在这个位置，这样的话就可以用Eclipse在GLib里爽起来了~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下Socket工具包libunp.a编译笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/12/unixxia-socketgong-ju-bao-libunp-dot-abian-yi-bi-ji/"/>
    <updated>2014-03-12T16:23:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/12/unixxia-socketgong-ju-bao-libunp-dot-abian-yi-bi-ji</id>
    <content type="html"><![CDATA[<p>1.README很重要，基本上跟着README走一遍就妥了，报错的话一定要仔细得去读错误信息，可以对错误的解决提供很大的帮助。我遇到的错误比较简单，是电脑里没有ar的打包指令，因为刚开始接触makefile，所以在这个不大的坑上也花了点时间才发现，还是在别人的机子上编译成功的，一对比才发现自己电脑上没有装&hellip;一定不要太自信，当时压根就没往这个方向想。</p>

<p>```c
Execute the following from the src/ directory:
&amp;
./configure    # try to figure out all implementation differences
cd lib         # build the basic library that all programs need
make           # use &ldquo;gmake&rdquo; everywhere on BSD/OS systems
&amp;
cd ../libfree  # continue building the basic library
make
&amp;
cd ../libroute # only if your system supports 4.4BSD style routing sockets
make           # only if your system supports 4.4BSD style routing sockets
&amp;
cd ../libxti   # only if your system supports XTI</p>

<pre><code>make           # only if your system supports XTI
</code></pre>

<p>cd ../intro    # build and test a basic client program
make daytimetcpcli
&amp;
./daytimetcpcli 127.0.0.1
&amp;
If all that works, you&rsquo;re all set to start compiling individual programs.
Notice that all the source code assumes tabs every 4 columns, not 8.
```</p>

<!--more-->


<p>2.开始蛮兴奋地在sublime上敲，觉得脱离了IDE后怎么看怎么高大上，但慢慢发现每更改了服务端客户端的程序后，想要运行测试要在三个终端窗口敲五次命令才可以，对于习惯了一个快捷键编译运行的我实在是一场灾难，果断还是要把服务端的开发迁移到eclipse上才是上上之道。因为不熟悉Makefile的语法，对于编译的配置又是一场灾难，折腾了好久才日出来。</p>

<p>首先要配置-L选项，定位于lib所在文件路径</p>

<p><code>c
/Users/workingspace/Demo/src/
</code>
再之后配置-l（小写L）选项，定位到具体的库名，虽然全名为libunp.a，但在配置的时候只写unp就够了,另外还要添加resolv，pthread这两个库</p>

<p><code>c
unp
resolv
pthread
</code></p>

<p>本来以为到这里就结束了，所以也就开始了悲剧的折腾之路，后来仔细对比了Makefile的显示信息，发现还要对-I（大写i）进行配置</p>

<p><code>c
/Users/src/lib
</code>
这个路径是编译lib时所在的路径，三个配置齐全，用的时候记得include就可以使用了。</p>
]]></content>
  </entry>
  
</feed>
