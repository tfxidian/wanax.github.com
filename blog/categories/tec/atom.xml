<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://sonnewilling.com/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://sonnewilling.com/"/>
  <updated>2014-03-13T16:46:09+08:00</updated>
  <id>http://sonnewilling.com/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GLib编译笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/13/glibbian-yi-bi-ji/"/>
    <updated>2014-03-13T15:38:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/13/glibbian-yi-bi-ji</id>
    <content type="html"><![CDATA[<h3>缘起</h3>

<p>最近做的一个项目是使用C写的，随着项目的深入发现需要通过不同的数据结构来完成需求，自己简单地去编写已经不能满足要求且在健壮性方面也存在着隐患，于是就琢磨着在网上找找看看有没有什么现成的C工具包来用，就这样，发现了GLib。</p>

<p>先来看下维基上的介绍：</p>

<blockquote><p>GLib是一个跨平台的、用C语言编写的库，起初是GTK+的一部分，但到了GTK+第二版，开发者决定把跟图形界面无关的代码分开，这些代码于是就组装成了GLib。GLib提供了多种高级的数据结构，如内存块、双向和单向链表、哈希表、动态字符串等。</p></blockquote>

<p>感觉功能刚好满足需要，类似于C++中的STL，果断搞起。</p>

<!--more-->


<h3>1.下载</h3>

<p>从网上搜索GLib找到了这里<a href="http://www.linuxfromscratch.org/blfs/view/svn/general/glib2.html">Linux From Scratch</a>，下载它的压缩包。</p>

<p>这个网站也把具体的编译安装方式写得很明白。</p>

<blockquote><h3>GLib Dependencies</h3>

<h4>Required</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/libffi.html">libffi-3.0.13</a> and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/python2.html">Python-2.7.6</a></p>

<h4>Recommended</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/pcre.html">PCRE-8.34</a>(built with Unicode properties)</p>

<h4>Optional</h4>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/postlfs/attr.html">attr-2.4.47</a>, <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/dbus.html">D-Bus-1.8.0</a> (required to run the tests), and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/gtk-doc.html">GTK-Doc-1.20</a></p>

<h4>Additional Runtime Dependencies</h4>

<p>Quoted directly from the INSTALL file: “Some of the mimetype-related functionality in GIO requires the update-mime-database and update-desktop-database utilities”, which are part of <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/shared-mime-info.html">shared-mime-info-1.2</a> and <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/desktop-file-utils.html">desktop-file-utils-0.22</a>, respectively.</p></blockquote>

<p>就是说想要安装GLib的话最起码得先把Required和Recommended里的东西装完才行。</p>

<h3>2.编译</h3>

<p>安装环境配好后就可以正式安装了，顺着那个网页往下走就能看到具体的方法：</p>

<p><code>c
./configure --prefix=/usr --with-pcre=system &amp;&amp; make
</code>
再然后</p>

<p><code>c
sudo make install
</code>
GLib在gcc里的使用是借助了一个叫pkg-configure的工具，这玩意儿的作用这位哥儿们说得很详细了，看他的介绍吧：<a href="http://www.chenjunlu.com/2011/03/understanding-pkg-config-tool/">理解 pkg-config 工具</a></p>

<p>其实定位到<code>/usr/lib/pkgconfigure</code>后会发现它里面放了很多你自己安装的库的.pc的配置文件，用vim随便打开一个发现它的内容是这样的：</p>

<p><code>c
   prefix=/usr
   exec_prefix=${prefix}
   libdir=${exec_prefix}/lib
   includedir=${prefix}/include
&amp;
   glib_genmarshal=glib-genmarshal
   gobject_query=gobject-query
   glib_mkenums=glib-mkenums
&amp;
   Name: GLib
   Description: C Utility Library
   Version: 2.38.2
   Requires.private: libpcre
   Libs: -L${libdir} -lglib-2.0 -lintl
   Libs.private:   -lpcre  -lintl  -liconv
   Cflags: -I${includedir}/glib-2.0 -I${libdir}/glib-2.0/include
</code>
看一下就明白了，基本上就是帮你写了一堆编译选项，免得到时候自己编译的时候要敲一坨，而且在不同的电脑上编译的时候也可以动态的调整路径，不用一遍遍的去改Makefile。</p>

<p>比如说自己编译一个使用了GLib的文件，可以这样敲：</p>

<p><code>c
gcc `pkg-config --cflags --libs glib-2.0`  hello.c -o hello
</code></p>

<p>–cflags 参数可以给出在编译时所需要的选项，而 –libs 参数可以给出连接时的选项。</p>

<p>当然如果不使用pkg-configure的话也可以类似这样子：</p>

<p><code>c
gcc  -L/usr/lib -I/usr/lib/glib/include/glib-2.0 hello.c -o hello -liconv -lresolv -lpcre -lintl -lglib-2.0
</code>
所以基本上还是简化了很多操作的。</p>

<h3>3.测试使用</h3>

<p>测试一下GLib中哈希表的使用吧：</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;glib.h></h1>

<p>int main(){</p>

<pre><code>    printf("Glib version: %u.%u.%u\n\n",glib_major_version,glib_minor_version,glib_micro_version);
</code></pre>

<p>&amp;</p>

<pre><code>    GHashTable* hash = g_hash_table_new(g_str_hash, g_str_equal);
    g_hash_table_insert(hash, "Virginia", "Richmond");
    g_hash_table_insert(hash, "Texas", "Austin");
    g_hash_table_insert(hash, "Ohio", "Columbus");
</code></pre>

<p>&amp;</p>

<pre><code>    printf("There are %d keys in the hash\n",g_hash_table_size(hash));
    printf("The capital of Texas is %s\n",g_hash_table_lookup(hash, "Texas"));
    gboolean found = g_hash_table_remove(hash, "Virginia");
    printf("The value 'Virginia' was %sfound and removed\n", found ? "" : "not ");
</code></pre>

<p>&amp;</p>

<pre><code>    g_hash_table_destroy(hash);
    return 0;
</code></pre>

<p>}
```
可以打印如下信息：</p>

<blockquote><p>Glib version: 2.38.2</p>

<p>There are 3 keys in the hash</p>

<p>The capital of Texas is Austin</p>

<p>The value &lsquo;Virginia&rsquo; was found and removed</p></blockquote>

<h3>4.搭配Eclipse</h3>

<p>嫌敲命令行麻烦的话也可以配到Eclipse上用。现在在Eclipse上有了pkg-configure的插件，可以对GLib直接勾选使用，但我安装后没有起到效果，不知道哪里出了问题<a href="https://code.google.com/p/pkg-config-support-for-eclipse-cdt/">pkg-config-support-for-eclipse-cdt</a>。但反正原理已经知道了，索性自己配一下也就妥了。</p>

<p>选中工程，在Project里找到Properties进入到下图的界面：</p>

<p><img src="/images/tec/GLib/eclipsecon.png" alt="image" /></p>

<p>在Libraries里配置GLib库的位置和名字，在Includes里配置GLib头文件的位置，我的头文件在这里</p>

<p><code>c
/usr/include/glib-2.0
</code>
其实按照教程正常安装的话基本上都会在这个位置，这样的话就可以用Eclipse在GLib里爽起来了~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下Socket工具包libunp.a编译笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/12/unixxia-socketgong-ju-bao-libunp-dot-abian-yi-bi-ji/"/>
    <updated>2014-03-12T16:23:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/12/unixxia-socketgong-ju-bao-libunp-dot-abian-yi-bi-ji</id>
    <content type="html"><![CDATA[<p>1.README很重要，基本上跟着README走一遍就妥了，报错的话一定要仔细得去读错误信息，可以对错误的解决提供很大的帮助。我遇到的错误比较简单，是电脑里没有ar的打包指令，因为刚开始接触makefile，所以在这个不大的坑上也花了点时间才发现，还是在别人的机子上编译成功的，一对比才发现自己电脑上没有装&hellip;一定不要太自信，当时压根就没往这个方向想。</p>

<p>```c
Execute the following from the src/ directory:
&amp;
./configure    # try to figure out all implementation differences
cd lib         # build the basic library that all programs need
make           # use &ldquo;gmake&rdquo; everywhere on BSD/OS systems
&amp;
cd ../libfree  # continue building the basic library
make
&amp;
cd ../libroute # only if your system supports 4.4BSD style routing sockets
make           # only if your system supports 4.4BSD style routing sockets
&amp;
cd ../libxti   # only if your system supports XTI</p>

<pre><code>make           # only if your system supports XTI
</code></pre>

<p>cd ../intro    # build and test a basic client program
make daytimetcpcli
&amp;
./daytimetcpcli 127.0.0.1
&amp;
If all that works, you&rsquo;re all set to start compiling individual programs.
Notice that all the source code assumes tabs every 4 columns, not 8.
```</p>

<!--more-->


<p>2.开始蛮兴奋地在sublime上敲，觉得脱离了IDE后怎么看怎么高大上，但慢慢发现每更改了服务端客户端的程序后，想要运行测试要在三个终端窗口敲五次命令才可以，对于习惯了一个快捷键编译运行的我实在是一场灾难，果断还是要把服务端的开发迁移到eclipse上才是上上之道。因为不熟悉Makefile的语法，对于编译的配置又是一场灾难，折腾了好久才日出来。</p>

<p>首先要配置-L选项，定位于lib所在文件路径</p>

<p><code>c
/Users/workingspace/Demo/src/
</code>
再之后配置-l（小写L）选项，定位到具体的库名，虽然全名为libunp.a，但在配置的时候只写unp就够了,另外还要添加resolv，pthread这两个库</p>

<p><code>c
unp
resolv
pthread
</code></p>

<p>本来以为到这里就结束了，所以也就开始了悲剧的折腾之路，后来仔细对比了Makefile的显示信息，发现还要对-I（大写i）进行配置</p>

<p><code>c
/Users/src/lib
</code>
这个路径是编译lib时所在的路径，三个配置齐全，用的时候记得include就可以使用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS应用发布流程]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/01/iosying-yong-fa-bu-liu-cheng/"/>
    <updated>2014-03-01T17:20:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/01/iosying-yong-fa-bu-liu-cheng</id>
    <content type="html"><![CDATA[<h3>概述</h3>

<p>整个发布流程有四个关键词，<em>Certificates</em>，<em>Identifiers</em>，<em>Devices</em>与<em>Provisioning Profiles</em>.</p>

<p>它们的相互关系如下图所示，</p>

<p><img src="/images/tec/IOSPub/pic_1.png" alt="image" /></p>

<p>简单说来便是用户身份验证书（Certificates），App应用身份ID（Identifiers），可用于开发的Devices三者合一生成一份Provisioning Profile，并将此profile下载到本机双击安装后就自然可以在xcode中找到了(注意左上角的“GooGuu”在配置发布时应将Target与Project的设置调未相同选项，以避免发布失败)。</p>

<!--more-->


<p><img src="/images/tec/IOSPub/pic_3.png" alt="image" /></p>

<h3>步骤分解</h3>

<h4>一.Certificates证书申请</h4>

<p>付费申请到开发者账号后首先要做的便是使用它来生成一个开发或者发布的证书，这个证书是App发布的起点，有了它便表明你是名已经被苹果公司认证过的开发人员并有权力发布自己开发的App到AppStore上去。</p>

<p><a href="http://my.oschina.net/joanfen/blog/133624">iOS开发者申请发布证书</a></p>

<p>证书申请的步骤这位姐姐讲解地很详细了，不需要再一一赘述，看到第J步&mdash;<em>下载证书，双击安装</em>便可以停一下，先来看Identifier。</p>

<h4>二.Identifiers-App ID的申请</h4>

<p>Certificates是表明你开发者身份的东西，花了近100的大洋肯定不可能只满足用来开发一款App，而是会进行多方面的尝试，这时候就需要通过App ID来对我们开发出的各种应用进行唯一的标示。</p>

<p>可以简单的理解为Certificates的苹果公司给你的身份证，而App ID是你给自己开发的App的一个身份证。</p>

<p><img src="/images/tec/IOSPub/pic_4.png" alt="image" /></p>

<h4>三.Devices的用处</h4>

<p>开发的App可以在Xcode自带的模拟器下运行调试，想要进行真机测试的话则需要用到Devices的配置选项了。</p>

<p>当你将外置设备连入苹果电脑，进入Xcode的Window->Organizer->Devices中便会发现自己的设备名称：</p>

<p><img src="/images/tec/IOSPub/pic_5.png" alt="image" /></p>

<p>现在的Xcode已经集成了添加Device的功能，点击连接后的设备名称，你会在右边的窗口中发现诸如“添加该设备到开发机”之类的选项。</p>

<p><img src="/images/tec/IOSPub/pic_6.png" alt="image" /></p>

<p>之后到Device里简单的验证一下便可以了，你会发现自己的设备序列号已经添加到了该列表里面。</p>

<p>这个Devices列表按照第二张图的样子看应该是会在最后跟AppID与Certificate打包在一起来生成Profile文件，这样开发者身份信息，App的身份信息，可用测试的设备信息都可以随时的调用。</p>

<h4>四.Provisioning Profiles的生成与使用</h4>

<p>还是继续从第K步&mdash;<em>生成证书对应的provision File</em> 看刚刚那位姐姐的讲解吧。</p>

<p><a href="http://my.oschina.net/joanfen/blog/133624">iOS开发者申请发布证书</a></p>

<h3>发布</h3>

<p>这样一步步下来，一份完成的Profile便拿在了手上，分为Development和Distribution两种，分别用于开发与发布的使用。</p>

<p>还不清楚的话可以看下这位哥儿们的讲解，更加的专业与细致。</p>

<p><a href="http://www.cnblogs.com/cywin888/p/3263027.html">关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系</a></p>

<p>接下来还剩下两步工作，一个是本地二进制文件的打包验证，一个是苹果网站的新App申请或者旧App版本更新的申请。</p>

<h4>1.苹果网站上的相关工作</h4>

<p>我们去到<a href="https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa">App Product</a>这里，在网站上对App进行配置。</p>

<p>大致可以理解为通知苹果公司我将会有一个App通过Xcode进行上传，你要注意接收啊之类云云。</p>

<p>如果之前已经有旧的版本了那很简单，进入“Manage Your Apps”的页面，点击你要更新的App进入一个新的页面，里面有个Button叫“Add Version”点击进入，有一个流程页面，唯一需要注意的是<em>填写的新的版本号需要跟本地项目的Target->General的下图位置处的版本号填写相同</em>，不然在最后打包完毕验证时会发生错误导致无法提交。</p>

<p><img src="/images/tec/IOSPub/pic_10.png" alt="image" /></p>

<p><img src="/images/tec/IOSPub/pic_9.png" alt="image" /></p>

<p>如果是第一次发布App则稍微有点麻烦，具体的还是参见刚刚那位姐姐的文章吧&hellip;</p>

<p><a href="http://my.oschina.net/joanfen/blog/133642">iOS 发布应用程序到App Store</a></p>

<h4>2.本地Xcode的相关工作</h4>

<p>将发布设备调节到下图的位置，前提是没有外置的设备连在苹果机上，其实连上也无所谓，只是文字显示不一样。</p>

<p><img src="/images/tec/IOSPub/pic_7.png" alt="image" /></p>

<p>然后点击Product->Archive来静待二进制文件的生成吧。</p>

<p>生成后会自动跳转到Window->Organizer->Archives，然后分别对打包好的App进行验证与最后的提交，就是这样了~</p>

<p><img src="/images/tec/IOSPub/pic_8.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Django框架网站搭建入门]]></title>
    <link href="http://sonnewilling.com/blog/2013/11/15/python-djangokuang-jia-wang-zhan-da-jian-ru-men/"/>
    <updated>2013-11-15T16:22:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2013/11/15/python-djangokuang-jia-wang-zhan-da-jian-ru-men</id>
    <content type="html"><![CDATA[<p>最近学习了下python，传说中的pyhon的框架比关键字还多果然名不虚传。想用pyhon搭个网站练练手，上网一搜果然一大把。看了下推荐各有利弊，但Django的文档比较全面，虽然说有点封闭，但也没要求多高，感觉拿来上手正合适不过了。</p>

<p><a href="http://django-chinese-docs.readthedocs.org/en/latest/index.html">Django 中文文档</a></p>

<p>这篇文章主要是个学习笔记的作用，就是根据上面的网站一步步搞起的。</p>

<p>Django是一个MVC框架，相比于Java的MVC SSH简单的不是一点半点，想之前搭SSH还通了个宵，现在看看Django的MVC简单到只有三个python文件，跟着教程一步步搭起来回过头才想起来这特么也是MVC的框架啊，自不待言。</p>

<p><img src="/images/tec/python-django.png" alt="image" /></p>

<p>上图是一个对Django MVC的简单示意，很容易可以看出，<code>view.py</code>是主管视图部分的，<code>model.py</code>主管模型层，遗憾没有个<code>control.py</code>，哈哈，<code>url.py</code>控制跳转，是为controller。</p>

<p>现在便一步步开始吧。</p>

<!--more-->


<h2>一.安装</h2>

<p>上周（November 6, 2013）Django才刚更新到1.6，<a href="https://docs.djangoproject.com/en/dev/releases/1.6/">Django 1.6 release notes</a>这里是一些新特性的介绍。</p>

<p>因为中文文档还是介绍的1.5的安装过程，所以先按着1.5的版本来吧。需要注意的是Django适用<code>python 2.6.5</code>到 <code>2.7</code> 的所有 Python 版本，还具有 <code>3.2</code> 和<code>3.3</code>版本的实验性支持，因为python3相对于2.x来说有了一些语法与库的更新，所以在版本选择上还是需要注意一下的，就比如在2.x中有关http请求的lib放在<code>httplib</code>中，而在python3中则在<code>urllib</code>中，倒是有个开源第三方库叫<code>httplib2</code>，看一些教程都推荐在python3中使用这个第三方库，是因为有诸如缓存之类的特性。</p>

<p>Django的安装不麻烦，<a href="https://www.djangoproject.com/download/">DownLoad</a>去这里下载压缩包，解压完进入文件目录执行</p>

<p><code>
sudo python setup.py install
</code>
就可以了。</p>

<p>可以终端进入python shell验证一下</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>import django
print(django.get_version())
1.5
```</p></blockquote></blockquote></blockquote>

<h2>二.项目启动</h2>

<p>对于一个Django项目有两个基本的概念</p>

<ol>
<li>project，这是对整个具体的项目的称号，我们一个网站便是一个project</li>
<li>app，相对于一个project可以细分很多app，也就是功能块的意思，我们可以建立很多app，并可以在/project/settings.py进行设置，也就是号称的即插即用。</li>
</ol>


<p>开启终端，定位到一个合适的目录，键入第一行命令，生成我们的第一个Django项目</p>

<p><code>
django-admin.py startproject mysite
</code>
<code>mysite</code>的名字便对应着project，这个看个人意志了。</p>

<p>妥当了后便是一个初步的网站架构</p>

<blockquote><p>mysite/</p>

<blockquote><p>   manage.py</p>

<p>   mysite/</p>

<blockquote><p>   <strong>init</strong>.py</p>

<p>   settings.py</p>

<p>   urls.py</p>

<p>   wsgi.py</p></blockquote></blockquote></blockquote>

<p>这是一个基本的目录层次</p>

<p><code>manage.py</code>是个命令行工具，可让你以各种方式与该 Django 项目进行交互，<code>settings.py</code>是对整个网站的一些基本配置，<code>urls.py</code>便是最外层的控制跳转，这里我们可以直接定位到具体的处理方法，但一般还是建议定位到相关的app，然后再让app里的<code>url.py</code>进行具体的跳转控制。<code>wagi.py</code>是一个对公共网关接口的配置，比如说放到新浪SAE的时候我们需要对这个文件进行编写配置。</p>

<p>初步介绍就是这样，shell定位到第一层的<code>mysite</code>上，输入</p>

<p><code>
python manage.py runserver
</code></p>

<p>去<code>http://127.0.0.1:8000/</code>进行访问，便可以看到初步的效果了。</p>

<h2>三.APP激活</h2>

<p>项目启动成功后我们可以进入app的建立与关联。</p>

<p><code>
python manage.py startapp polls
</code></p>

<p>使用上面的命令在根目录建立一个app。</p>

<blockquote><p>polls/</p>

<blockquote><p>   <strong>init</strong>.py</p>

<p>  models.py</p>

<p>   tests.py</p>

<p>   views.py</p></blockquote></blockquote>

<p>初始的app一般是这样的目录结构，一般还要自己新建一个<code>url.py</code>以便接过在根目录下<code>url.py</code>跳转控制的大旗~</p>

<p><code>model.py</code>便是模型层中相关的具体模型了，<code>view.py</code>顾名思义，在通过<code>url.py</code>控制跳转到这个文件后对请求做具体处理，一般传参为<code>request</code>而返回一个<code>HttpResponse</code>。</p>

<p>进入根目录下面的<code>settings.py</code>对app进行插入</p>

<p>```
INSTALLED_APPS = (</p>

<pre><code>'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.sites',
'django.contrib.messages',
'django.contrib.staticfiles',
# Uncomment the next line to enable the admin:
# 'django.contrib.admin',
# Uncomment the next line to enable admin documentation:
# 'django.contrib.admindocs',
'polls',
</code></pre>

<p>)
```</p>

<p>使用</p>

<p><code>
python manage.py syncdb
</code>
告诉项目对app进行同步安装。至此，一个初步的app便配置成功了。</p>

<h2>四.APP中编写第一个视图</h2>

<p>让我们编写第一个视图。打开文件 polls/views.py 并在其中输入以下 Python 代码</p>

<p>```py
from django.http import HttpResponse
def index(request):</p>

<pre><code>return HttpResponse("Hello, world. You're at the poll index.")
</code></pre>

<p>```</p>

<p>在 Django 中这可能是最简单的视图了。为了调用这个视图，我们需要将它映射到一个 URL – 为此我们需要配置一个URLconf 。</p>

<p>在 polls 目录下创建一个名为 urls.py 的 URLconf 文档。 你的应用目录现在看起来像这样</p>

<blockquote><p>polls/</p>

<blockquote><p>   <strong>init</strong>.py</p>

<p>   admin.py</p>

<p>   models.py</p>

<p>   tests.py</p>

<p>   urls.py</p>

<p>   views.py</p></blockquote></blockquote>

<p>在 polls/urls.py 文件中输入以下代码：</p>

<p>`&ldquo;py
from django.conf.urls import patterns, url
from polls import views
urlpatterns = patterns(&rdquo;,</p>

<pre><code>url(r'^$', views.index, name='index')
</code></pre>

<p>)
```</p>

<p>这是一个简单的正则匹配，大概意思便是进入根url的话则直接去执行<code>view.py</code>里的<code>index</code>方法，便是我们刚刚定义过的那个函数。</p>

<p>下一步是将 polls.urls 模块指向 root URLconf 。在 mysite/urls.py 中插入一个 include() 方法，最后的样子如下所示</p>

<p>`&ldquo;py
from django.conf.urls import patterns, include, url
from django.contrib import admin
admin.autodiscover()
urlpatterns = patterns(&rdquo;,</p>

<pre><code>url(r'^polls/', include('polls.urls')),
url(r'^admin/', include(admin.site.urls)),
</code></pre>

<p>)
```</p>

<p>现在你在 URLconf 中配置了 index 视图。通过浏览器访问 <a href="http://localhost:8000/polls/">http://localhost:8000/polls/</a> ，如同你在 index 视图中定义的一样，你将看到 “Hello, world. You’re at the poll index.” 文字。</p>

<p>更多的一些视图编写方法请参见<a href="http://django-chinese-docs.readthedocs.org/en/latest/intro/tutorial03.html">这里</a></p>

<p>这里只是简单的介绍了下的客户请求服务器控制跳转处理请求并返回http对象的过程，并没有介绍如何搭配数据库模型层的运用，想进行细致的学习请移步<a href="http://django-chinese-docs.readthedocs.org/en/latest/index.html">Django 中文文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress搭建个人博客]]></title>
    <link href="http://sonnewilling.com/blog/2013/11/14/shi-yong-octopressda-jian-ge-ren-bo-ke/"/>
    <updated>2013-11-14T16:45:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2013/11/14/shi-yong-octopressda-jian-ge-ren-bo-ke</id>
    <content type="html"><![CDATA[<p><img src="/images/tec/octopress-header.png" alt="image" /></p>

<p>十月份用octopress搭建了一个个人博客，现在把大概的流程介绍一下，常用的几个命令也在这里记下来。</p>

<p><a href="http://http://octopress.org/">Octopress</a>是个利用<a href="https://github.com/mojombo/jekyll">Jekyll</a>引擎开发的博客系统。它将生成的静态页面push到我们自己的github上，可以很好的在github page上展示。号称程序员博客逼格利器</p>

<blockquote><p>A blogging framework for hackers.</p></blockquote>

<!--more-->


<h3>首先是搭建发布环境</h3>

<p>Octopress需要Ruby环境，前几天自己电脑上装的Ubantu10.0自带的Ruby1.8.7试过了不行，起码要更新到Ruby1.9.1吧，官方的建议是1.9.3.</p>

<p>安装Ruby有两个方法，一个是直接去官网下载Ruby包，解压缩，安装。另一个是使用RVM(Ruby Version Manager)来负责安装和管理Ruby的环境。</p>

<p>在Mac电脑上我直接下载安装了Rvm</p>

<p><code>
curl -L https://get.rvm.io | bash -s stable --ruby
</code></p>

<p><code>
rvm install 1.9.3
rvm use 1.9.3
rvm rubygems latest
</code></p>

<p>参见<a href="http://octopress.org/docs/setup/rvm/">Installing Ruby With RVM</a></p>

<p>这样便简单搞定，但Ubantu上rvm死活搞不定，网上搜了下使用第一种方法直接安装算完了，也不麻烦。</p>

<h3>然后便是安装Octopress</h3>

<p>先把Octopress从网上down下来</p>

<p><a href="https://github.com/imathis/octopress">Octopress</a></p>

<p>电脑上有git的话简单一点</p>

<p><code>
git clone git://github.com/imathis/octopress.git octopress
</code></p>

<p>解压进入项目目录安装相关依赖</p>

<p><code>
cd octopress
gem install bundler
rbenv rehash
bundle install
</code>
参见<a href="http://octopress.org/docs/setup/">Octopress Setup</a></p>

<p>这几步是把发布Octopress的环境搞定，还没有正式开始搭建Octopress，我在Mac上发布的博客，在Ubantu从git上check下来，也要这么来一遍才能正式使用Octopress。</p>

<p>最后安装默认的Octopress 主题。</p>

<p><code>
rake install
</code></p>

<h3>接下来是配置Octopress</h3>

<p>主要是对<code>_config.yml</code>进行修改，其它的话自行研究吧。</p>

<p>具体配置参见<a href="http://octopress.org/docs/configuring/">Configuring Octopress</a>写得很详细了。</p>

<p>搞定配置后可以先大体的看下样式</p>

<p><code>
rake generate//通过引擎生成静态网页
rake preview//本地预览
</code>
<a href="localhost:4000">localhost:4000</a>进行本地预览</p>

<h3>觉得差不多了就可以把Octopress发到github上了</h3>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照：username.github.com的方式命名。待发布完毕可以直接使用<code>http://username.github.com</code>来访问博客。同时可以把博客的源码放到source分支下，并把生成的内容提交到master分支。这样随便换到哪里的电脑上都可以check下来接着写了。</p>

<p>第一步是对我们新建的目录进行建立与初始化，会提示输入你的git的账号和密码，一次确认完毕以后你每次提交都会跑到你确认的git账号下的github.com/username/username.github.com下了。</p>

<p>本地生成一下静态Html发上去就妥了</p>

<p><code>
rake generate//生成
rake deploy//发布
</code></p>

<h3>最后说下写博客的常用命令</h3>

<p><code>
rake new_post["title"]
</code></p>

<p>这是新建一篇文章，存放在<code>source/_posts</code>目录下面，使用的是markdown语法，具体规则不麻烦，大家可以自己谷歌下。Mac下用Mou进行编辑很方便，Linux的话线上编辑会好一点，chrome有不少插件，其中一个叫Ma‘de，好像是作者用以表达对母亲的爱…</p>

<p><code>
 rake generate
 git add .
 git commit -am "Some comment here."
 git push origin source
 rake deploy
</code></p>

<p>使用上面几条命令生成与发布博客，中间的三条git命令是把博客的源码放到source的分支上，以便在不同的电脑上编辑博客。</p>

<p>参见<a href="http://octopress.org/docs/blogging/">Blogging Basics</a></p>
]]></content>
  </entry>
  
</feed>
