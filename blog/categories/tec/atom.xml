<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://sonnewilling.com/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://sonnewilling.com/"/>
  <updated>2014-11-02T16:47:37+08:00</updated>
  <id>http://sonnewilling.com/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VC USB 串口通信]]></title>
    <link href="http://sonnewilling.com/blog/2014/08/11/vc-usb-chuan-kou-tong-xin/"/>
    <updated>2014-08-11T11:03:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/08/11/vc-usb-chuan-kou-tong-xin</id>
    <content type="html"><![CDATA[<h2>楔子</h2>

<p>前段时间搞完了聊天服务器后也没有很多事情，因为系统瓶颈停留在数据库读写层面，所以研究了一两周的NOSQL和Cache。NOSQL快是快但key-value型的数据结构实在太过简单，感觉真用起来并不是很方便，Cache倒相对来说可行一些，开多一个服务罢了，其实简单的逻辑自己也能实现。就这样纠结来纠结去的，发现其实现在的服务倒也完全够用，压力测试了下，能撑到1500的并发，想来刚上线估计也最多几百号人能同时聊天就不错了，所以就先研究至此，撑不住了再换，不要过早优化嘛。</p>

<!--more-->


<p>就这样决定先找别的事做做，恰好项目里有需要用到Flash的ANE技术来实现Flash与硬件通信，Flash自然不会写，但用VC进行串口通信打包成DLL给Flash调用这个还是可以研究下的。</p>

<p>ANE这里就不再细谈，大体上就是Flash中调用其它语言的一种技术，通过它可以实现一些Flash做不到的东西，比如说底层通信啥的。这里主要讲USB串口通信这一块儿。</p>

<p>串口通信翻了下书发现还是有很多标准的，而现行最流行的就是USB了，所以在网上关于此的资料还是很好找的。</p>

<p>这篇文章的内容主要由三个部分组成：</p>

<ol>
<li>串口连接的建立与简单阻塞通讯</li>
<li>通过API调用自动查询当前插入的USB设备并建立连接</li>
<li>区别于简单阻塞的通讯方式，如重叠IO与事件通知</li>
</ol>


<h2>一，建立连接与阻塞通讯</h2>

<p>在WIN下面，对于串口一类的硬件设备也是认定为文件的一种，所以也可以使用文件的方式来创建打开使用：</p>

<p>```c
HANDLE h_com = CreateFile((LPCWSTR)&ldquo;COM4&rdquo;,   //设备名</p>

<pre><code>                GENERIC_READ || GENERIC_WRITE, //访问模式，可同时读写
                0,                             //共享模式，0表示不共享
                NULL,                          //安全性设置，一般使用NULL
                OPEN_EXISTING,                 //该参数表示该设备必须存在否则创建失败，串口通讯需此设置
                FILE_ATTRIBUTE_NORMAL
                0);
</code></pre>

<p>```</p>

<p>首先初始化一个句柄<code>h_com</code>，让它指向所要打开设备的串口号，之后对该设备的所有操作均需通过该句柄来执行。</p>

<p>之后便是对此串口的一些基本设置，</p>

<h4><em>超时选项</em></h4>

<p><code>c
/*设置串口的超时时间，均设为0，表示不使用超时限制*/
COMMTIMEOUTS  CommTimeouts;
CommTimeouts.ReadIntervalTimeout = 0;
CommTimeouts.ReadTotalTimeoutMultiplier = 0;
CommTimeouts.ReadTotalTimeoutConstant = 0;
CommTimeouts.WriteTotalTimeoutMultiplier = 0;
CommTimeouts.WriteTotalTimeoutConstant = 0;
SetCommTimeouts(h_com, &amp;CommTimeouts);
</code></p>

<h4><em>DCB参数配置</em></h4>

<p>因为DCB结构体中选项较多，故一般的配置方式是先通过<code>GetCommState</code>获取默认的DCB配置选项，再根据个人需求进行相应的修改。</p>

<p>```c
/<em>将ANSI字符串转换为UNICODE字符串</em>/
DWORD dwNum = MultiByteToWideChar(CP_ACP, 0, szDCBparam, -1, NULL, 0);
wchar_t *pwText = new wchar_t[dwNum];
if (!MultiByteToWideChar(CP_ACP, 0, szDCBparam, -1, pwText, dwNum))
{</p>

<pre><code>bIsSuccess = TRUE;
</code></pre>

<p>}
/<em>获取当前串口配置参数，并且构造自定义DCB参数</em>/
bIsSuccess = GetCommState(h_com, &amp;dcb) &amp;&amp; BuildCommDCB(pwText, &amp;dcb);
/<em>开启RTS flow控制</em>/
dcb.fRtsControl = RTS_CONTROL_ENABLE;
dcb.fRtsControl = RTS_CONTROL_ENABLE;
dcb.fBinary = TRUE;
dcb.fParity = TRUE;
dcb.ByteSize = 8;
dcb.Parity = ODDPARITY;
dcb.StopBits = ONESTOPBIT;
delete[] pwText;
SetCommState(h_com, &amp;dcb);
```</p>

<h4><em>清空缓冲区</em></h4>

<p>对句柄进行了一系列操作，保险起见清空一下缓冲区。</p>

<p><code>c
PurgeComm(h_com, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
</code></p>

<p>如此，一个完整的串口句柄就构造完毕了。接下来是进行阻塞读的测试。</p>

<p>首先，我们可以使用<code>ClearCommError</code>这个方法获取当前读缓冲区里的数据大小，通过轮询的方式阻塞在这里，当缓冲区里有数据的时候我们再进行下一步的动作。</p>

<p>```c
int get_dirty_len() {</p>

<pre><code>DWORD dwError = 0;  
COMSTAT  comstat;   
memset(&amp;comstat, 0, sizeof(COMSTAT));
UINT BytesInQue = 0;
if (ClearCommError(h_com, &amp;dwError, &amp;comstat)) {
    BytesInQue = comstat.cbInQue;
}
</code></pre>

<p>}
```</p>

<p>当有数据到来便可以直接读取了：</p>

<p>```c
while(h_comm->is_working) {</p>

<pre><code>int len = get_dirty_len();
if (len == 0) {
    Sleep(SLEEP_TIME_INTERVAL);
    continue;
}
char recv[10];
int recv_len;
ReadFile(h_com, recv, len, &amp;recv_len, NULL);
</code></pre>

<p>}
```</p>

<p>写与读类似</p>

<p><code>c
WriteFile(h_com, send, len, &amp;send_len, NULL);
</code></p>

<p>如上，一个简单的阻塞串口读写Demo便完成了。</p>

<h2>二，检测查询插入的USB设备信息</h2>

<p>因为是Flash直接对DLL调用进行设备连接，所以在C层面需要主动获取连接上的端口名建立连接，并将连接设备的信息返回给Flash调用者，故需要使用另一组工具完成任务。</p>

<p>在WIN下面有一组API可以完成此项功能：</p>

<p><code>c
SetUpAPI
</code></p>

<p>摸索<code>setupapi</code>的使用方法着实费了些力气，归结起来主要有两点</p>

<ol>
<li>英文阅读能力不足，MSDN上面说明的使用方法并没有深刻理解</li>
<li>整体知识把握不足，摸着石头过河，边试边蒙</li>
</ol>


<p>说到底还是要多看书，多读英文资料，大体结构把握了也知道从何下手，而且国内博客的资源大多抄来抄去，并没有多关注其所以然，代码贴来贴去，试着心烦远不如一点一点学起来得畅快。</p>

<p>言归正传，获取端口信息依旧要从句柄入手。</p>

<h4><em>1.借助API获取某一类设备的相关信息</em></h4>

<p>```c
HDEVINFO hDevInfo = SetupDiGetClassDevsA(</p>

<pre><code>    (LPGUID)&amp;GUID_DEVCLASS_PORTS,
    0,
    0,
    DIGCF_PRESENT);
</code></pre>

<p>```</p>

<p>关于<code>LPGUID</code>可以自己初始化，一般的普通设备系统也提供了宏定义，可以看到我这里使用了<code>GUID_DEVCLASS_PORTS</code>，指明需要获取的是<code>PORT</code>（COM端口）一类的设备信息。</p>

<h4><em>2.遍历连接设备，获取设备信息</em></h4>

<p>```c
char szBuf[MAX_PATH];
ZeroMemory(szBuf, MAX_PATH);
int i = 0;
SP_DEVINFO_DATA   spDevInfoData = { sizeof(SP_DEVINFO_DATA) };
for (i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &amp;spDevInfoData); i++) {</p>

<pre><code>char *id = (char *)malloc(10 * sizeof(char));
char *port = (char *)malloc(10 * sizeof(char));
//get ID
if (SetupDiGetDeviceInstanceId(hDevInfo, 
    &amp;spDevInfoData, (PWSTR)szBuf, MAX_PATH, NULL)) {
    char dest[MAX_PATH];
    ZeroMemory(dest, MAX_PATH);
    get_str(szBuf, dest);
    get_id(dest, id);
}
ZeroMemory(szBuf, MAX_PATH);
//get port
if (SetupDiGetDeviceRegistryProperty(hDevInfo, 
    &amp;spDevInfoData, SPDRP_FRIENDLYNAME, NULL, (PBYTE)szBuf, MAX_PATH, NULL)) {
    char dest[MAX_PATH];
    ZeroMemory(dest, MAX_PATH);
    get_str(szBuf, dest);
    get_com(dest, port);
}
strcpy(coms[i], port);
strcpy(vids[i], id);
*len = i;
</code></pre>

<p>}
```</p>

<p><code>c
SetupDiEnumDeviceInfo
</code></p>

<p>这个函数通过<code>Index</code>进行依次查找设备，若设备不存在则返回空终止遍历。</p>

<p>所以在最后我们可以通过初始化的句柄<code>hDevInfo</code>与遍历出来的设备信息<code>spDevInfoData</code>来查找我们想要获取的具体信息。</p>

<h2>三，重叠IO与事件通知</h2>

<h3>重叠IO</h3>

<p>重叠IO解决的是受IO性能的影响不能第一时间将预期的字节数全部读完必须时阻塞等待在<code>ReadFile</code>，待全部数据传输完毕才返回的问题。</p>

<p>简单说来便是假如我想读1000个字节的数据从串口设备，但当前传输速度只有100K/S，那岂不是要在<code>ReadFile</code>上阻塞10s才会返回？正常情况下是这样的，而重叠IO便是解决此一问题的正确方法。</p>

<p>它的大体思路是当主线程第一时间没有从<code>ReadFile</code>中读出预期的字节数后便立即返回<code>FALSE</code>，继续其它操作，另一方面会在后台单开一个线程执行读取操作，真正读取完毕后再返回主线程进行相应的逻辑处理。</p>

<p>下面看详细步骤：</p>

<h4><em>1.句柄设置为可重叠模式</em></h4>

<p>```c
HANDLE h_com = CreateFileA(port,</p>

<pre><code>    GENERIC_READ | GENERIC_WRITE, 
    0,                           
    NULL,                         
    OPEN_EXISTING,                
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED/*可重叠模式*/,
    0);
</code></pre>

<p>```</p>

<h4><em>2.使用可重叠模式进行读取</em></h4>

<p>```c
DWORD dwRes, deRead;
char cRecved[100];
int BytesRead;
OVERLAPPED ol;
ol.Offset = 0;
ol.OffsetHigh = 0;
ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
if (ReadFile(m_hComm, cRecved, len, &amp;BytesRead, &amp;ol)) {</p>

<pre><code>//success!
</code></pre>

<p>} else { //无法第一时间读出数据</p>

<pre><code>dwRes = WaitForSingleObject(ol.hEvent, 5000);//设置5s超时
if (dwRes == WAIT_OBJECT_0) {
    if (!GetOverLappedResult(h_com, &amp;ol, &amp;dwRead, TRUE)) {
        //操作失败，使用GetLastError获取失败信息
    } else {
        //操作成功，数据读出并存入cRecved数组中
    }
}
</code></pre>

<p>}
```</p>

<p>这便是一个可重叠IO的简单示例，可以看出当<code>ReadFile</code>返回<code>FALSE</code>后，我们通过<code>OVERLAPPED</code>结构体获取该操作的事件，并通过<code>WaitForSingleObject</code>来等待异步线程读操作的完成，然后通过<code>GetOverLappedResult</code>验证下最终读取的字节数，便算完成了。</p>

<h3>事件通知</h3>

<p>在一般的通信情景中，大多是有个线程一直等待消息的到来然后进行读取。在开篇的例子中我使用的是简单的睡眠轮询的方式，但在真实地应用场景中这样做显然是不符合实际的，于是便需要使用基于事件通知的方式。</p>

<p>既然是事件监听，那第一步需要做的便是添加事件监听事件，这一步是通过对句柄的设置来完成的：</p>

<p><code>c
SetCommMask(h_com, EV_RXCHAR | EV_TXEMPTY);
</code></p>

<p><code>EV_RXCHAR</code>表示一旦有字节到来便触发事件，<code>EV_TXEMPTY</code>表示缓冲区为空的时候触发事件。</p>

<p>接下来便是对此事件进行监听，并在事件到来时将数据读出：</p>

<p>```c</p>

<pre><code>while (is_running) {
    COMSTAT ComStat;
    DWORD dwRes, dwMask;
    ZeroMemory(myChar, 10);
    OVERLAPPED ol;
    //创建等待事件
    ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    WaitCommEvent(h_com, &amp;dwMask, &amp;ol);
    //对该事件进行等待
    dwRes = WaitForSingleObject(ol.hEvent, 1000000);
    if (dwRes == WAIT_OBJECT_0) {
        if (dwMask &amp; EV_RXCHAR) {
            rol.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            char str[20];
            ZeroMemory(str, 20);
            DWORD dwRead;
            DWORD dwErrors;
            COMSTAT Rcs;
            int i;
            //获取缓冲区字节数量
            ClearCommError(h_com, &amp;dwErrors, &amp;Rcs);
            if (Rcs.cbInQue &gt; 0) {
                if (ReadFile(h_com, &amp;str, Rcs.cbInQue, &amp;dwRead, &amp;rol)) {
                    printf("%d-%d-%d\n", Rcs.cbInQue, dwRead, str[0]);
                }
                else {
                    printf("error\n");
                }
            }
        }
    }
    PurgeComm(h_com, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
}
</code></pre>

<p>```</p>

<p>以上便是事件触发式读取的基本使用方法，需要注意的是，事件触发IO可以搭配重叠IO进行使用，以获得更好的效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX程序制作成WIN Server笔记]]></title>
    <link href="http://sonnewilling.com/blog/2014/06/14/unixcheng-xu-zhi-zuo-cheng-win-serverbi-ji/"/>
    <updated>2014-06-14T16:55:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/06/14/unixcheng-xu-zhi-zuo-cheng-win-serverbi-ji</id>
    <content type="html"><![CDATA[<h1>初</h1>

<p>四五月份折腾完聊天服务器后就放了下来开始做个公司的CMS，重拾PHP的感觉还不错。几年不见多了很多框架，随便挑一个用着也很是方便，感觉现在做应用层的开发真是越来越简单了。各种框架工具一应俱到，从UNIX脱离出来重新投入到一键式的开发环境中真有点说不出的幸福。</p>

<p>开始的时候以为编程的世界是个江湖，每个码农都应该朝着绝顶高手的目标不断努力，只有将自己的武功修炼到化境才能算得上功成名就，渐而渐的却发现自己所处的环境跟江湖有不少区别的。也许在自己不知道的层面上还是各种武林高手呼风唤雨，但就现在自己所处的位置却是一个战场无疑。自己的能力与各种框架工具相比就算提升了几倍也是显得那么微不足道。就好比之前写聊天程序时各种尝试，从多进程到多线程，从线程池到多路复用，就自己的能力而言性能是在可观的提升的，心里也有些小得意。直到后面用上了<code>Libevent</code>&hellip;回头看看自己的努力就像天边的浮云，看上去很美而已。</p>

<!--more-->


<p>现在的产品开发正朝着越来越高的层次迈进，对于程序员的素质要求也逐步的降低，很多时候小码农真的像战场上的士兵一样，每人一件标准式的兵器往前冲就是了，真正能主导战场走向的反而是居于幕后激昂指点的PM。</p>

<p><code>C++</code>11出了<code>shared_ptr</code>，苹果手里的<code>OC</code>搭配上<code>ARC</code>还尚嫌不足轰轰烈烈来了个<code>Swift</code>，<code>JS</code>不满足于前端的限制整了套<code>NODEJS</code>，<code>Python</code>的<code>Django</code>，<code>PHP</code>的<code>Codeigniter</code>，大学时所学的操作系统，指针，数据结构已经渐渐地离我们远去，能不能说这是一个最好的时代却也是一个最坏的时代呢？</p>

<h1>缘</h1>

<p>公司现在跑的测试服务器装的是WIN SERVER的系统，没道理为了一个小程序重装系统，所以就开始了踩坑遍地的跨平台旅程。</p>

<h1>足下</h1>

<p>首先需要的是确定使用什么工具进行WIN的编译。以为使用的是Mac做的第一次开发，借助了Eclipse+GCC，所以第一想法也是在WIN下使用这一套环境，进行Eclipse+MinGW相信也可以搞定。</p>

<p>在对GLib进行配置的时候还是相对顺利的，其实在自己心里设想的就是把用到的各种库填好相应的头引用，lib引用就足以使用了。只是后面的历程说明老是把事情往简单想早晚会吃大亏的。</p>

<p>在套Libevent就出现了很多问题，而且因为不知道是不是因为年代比较久远且与现在的潮流脱节，在Google上搜来搜去也就那么几篇文章，我在配的时候出现的<code>PROPC_MESSAGE ERROR</code>根本搜不出所以然来。</p>

<p>于是乎在折腾了N个日子后的一个悲观的整个人都不好了的下午，试想着不如直接用<code>Cygwin</code>算了，顶多从新把东西都编译一遍，但最起码这玩意儿咱做过一遍心里还有底。幸运的是下回来<code>Cygwin</code>刚试用了感觉一切良好的时候下班的时间到了。</p>

<p>回家吃饱饭在图书馆空调的沁脾下逐渐平息了青春的躁动决定还是另谋它法，<code>Cygwin</code>一条路走到黑搞不好被炒了鱿鱼都说不准。由此可见下班及时回家是多么的重要。</p>

<p>第二天回来重新来过开始用起<code>VS</code>来。WIN8配上VS，一切感觉都是那么的美好，阳光透过窗子洒在脚上提醒我到了穿拖鞋上班的季节。</p>

<p>GLib的配置依旧十分顺利，还是卡在了Libevent上。对Libevent的编译十分简单，使用VS自带的<code>nmake</code>可以很轻松的将Libevent的三个lib给编译出来。但在引用的过程中总会出现莫名其妙的错误。开始考虑的是x86与x64导致的问题，但分两种情况编译后问题依然存在。卡了快一天后在网上找到了一个配置好的Demo，运行竟然成功了。通过编译参数的详细对比发现在指定运行库的地方需要调整为<code>/MT</code>的模式，具体的原因参见这篇文章<a href="http://msdn.microsoft.com/zh-cn/library/2kzt1wy3.aspx">/MD、/MT、/LD(使用运行库)</a>，有点踏破铁鞋无觅处，得来全不费功夫的感觉。虽然配置好了但还是有点知其然不知其所以然。</p>

<p>接下来便是再接再厉将<code>mysql</code>的库搭好环境便算彻底搞定了。有时候总觉得事情老是在自己最放心的地方峰回路转，其实说白了还是自己的基本功不扎实，觉得简单并不一定了解到了方方面面，也可能自己并不知道其中的重点难点所在而又继续踩坑。对于<code>mysql</code>的配置这点感触尤其深刻。总觉得相当简单手到擒来，结果还是卡了半天，最后才发现自己选择的是x64的版本与工程版本不匹配，更换后终于拨云见日。</p>

<p>整体环境搭出来后才感觉轻松了不少，觉得这事儿终于算是有些眉目了。虽然WIN下面的socket是自己实现的，但还是跟UNIX的API保持一致的。只需在开始的时候来一句<code>WSAStartup</code>就万事大吉了。其它的便是一些接口的细节修改。在VS下面很多如<code>sprintf</code>，<code>fopen</code>的函数会报不安全的错误，建议修改成<code>sprintf_s</code>，<code>fopen_f</code>，懒得修改的话也可以直接对工程进行配置，忽略这个类型的警告。</p>

<p>最后的成功运行让我心中长出一口恶气，正好是周五的下午，收拾东西踢个靓球。</p>

<h1>峰回</h1>

<p>六月初的时候公司换了新的地点，大了不少不说离着也近感觉还是不错的。新地方上班的第一天便是赶紧在Mac上装个WIN8，之前编译的时候对着项目经理的13寸小电脑佝偻的一个多星期，说什么也不能再受罪了。</p>

<p>这年头来个双系统还是真是方便，纯鼠标操作点几下就搞定了。按完以后面对着WIN8高大上的界面不禁手痒，来几盘CS再方便不过。</p>

<p>这里上班有大食堂可以吃，不用像之前那样叫外卖了，不过之前也没怎么吃外卖，开始是炒了菜带来吃，嫌麻烦改成了面包火腿黄瓜鸡蛋，再后来还是嫌麻烦两片面包夹个鸡蛋足矣。新地方试了几天饭堂发现还是面包鸡蛋吃着爽快，唯一值得留恋的是中午吃饭可以遇到两位管理处的小妹妹，长得都还蛮不错的。</p>

<p>正当觉得要脱离苦海的时候boss要求要把exe做成服务，这样开机可以直接启动更方便。没啥好说的，继续耕耘呗。</p>

<p>开始的时候没什么思路，在网上简单的搜索了下发现有个<code>sc</code>的命令可以直接将exe制作成服务，很是开心。结果制作出来的服务跟不启动不了，再仔细一搜发现关于服务的工程需要调用特定的WIN API才行，觉得心里有点毛，不会又要一阵折腾吧。</p>

<p>在VS下面发现可以直接新建c#的服务工程，但又不能直接用c的代码，想着可以将做的项目做成lib再在里面调用，觉得十分可行。为了验证自己这个想法的可行性，背起书包回家吃饭。</p>

<p>第二天再来的时候果然觉得这个方案不是很靠谱，因为不熟悉WIN API而想方设法绕过去看上去很简单，搞不好又是一坨屎出来。静下来琢磨下过程，直接用c来调用的话应该也不会很难，就当学习呗。</p>

<p>大体的了解了下思路，发现没有自己想象的难，大体就是开始的时候初始化一个叫<code>分配表</code>的结构体，在这个结构体可以定义服务的名字和主调用程序，然后调用一个叫dispatch的函数，大体意思是这个dispatch会把当前进程转换为分配表的进程，然后再通过分配表启动一个新的线程，再用这个线程调用我们的主程序。在这个主程序中我们还需要对当前服务的状态进行不同程度的修改，然后把自己写好的程序放进去就行了。另外还需要写一个<code>Handler</code>来接收这个服务的各种返回状态。</p>

<p>需要注意的是启动的服务无法打印信息，需要搭配日志来使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于C的Socket聊天服务器]]></title>
    <link href="http://sonnewilling.com/blog/2014/05/05/ji-yu-cshi-de-socketliao-tian-fu-wu-qi/"/>
    <updated>2014-05-05T16:26:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/05/05/ji-yu-cshi-de-socketliao-tian-fu-wu-qi</id>
    <content type="html"><![CDATA[<p>前段时间使用C借助libevent，glib实现了一个简单的可以单聊，群聊的服务器，今天因为需求有些改动所以又翻出来改了一下。果然一日不见如隔三秋，虽说是自己写的东西，但基本上已经忘得七七八八了。觉得有必要在这里记录一下，省得以后又悲剧。</p>

<h2>一，工具类</h2>

<h3>1.libunp.a</h3>

<p>用到的第一个库便是它，因为它是《UNIX网络编程》的示例代码的工具库&hellip;开头写的测试程序基本都是照着示例代码改来改去，自然也是用的一样的函数来实现。觉得对于一般的读写和各种包裹函数都是很有用的。具体的不用细说，还是认真翻书来得实在。</p>

<h3>2.GLib</h3>

<h4>GHashTable</h4>

<p>这里基本的数据结构如哈希表之类的使用了GLib来做主角，另外它的GString也很好用，可以很方便的初始化与格式化字符串，个人感觉比C风格的字符串要好用一些。</p>

<p>GLib哈希表支持各种不同的结构，如果觉得<code>int</code>,<code>string</code>不够用可以直接使用指针，对于我来说已经相当足够。</p>

<p><code>c
GHashTable *user_to_bev_map = g_hash_table_new(g_direct_hash,g_direct_equal);
g_hash_table_insert(user_to_bev_map, GINT_TO_POINTER(u_id), GINT_TO_POINTER(bev));
struct bufferevent *bev = g_hash_table_lookup(user_to_bev_map,GINT_TO_POINTER(to_id));
</code></p>

<p><code>g_direct_hash</code>,<code>g_direct_equal</code>代表初始化的类型，详细的介绍如下:</p>

<blockquote><p>Hash values returned by hash_func are used to determine where keys are stored within the GHashTable data structure.</p>

<p>The <code>g_direct_hash()</code>, <code>g_int_hash()</code>, <code>g_int64_hash()</code>, <code>g_double_hash()</code> and <code>g_str_hash()</code> functions are provided for some common types of keys.</p>

<p>If hash_func is NULL, g_direct_hash() is used.</p></blockquote>

<!-- more -->


<h4>GString</h4>

<p>相比于C风格的字符串需要定长初始化，拼接赋值之类的，GString提供的字符串要人性化很多，还内置了长度的属性，可以很方便的调用。</p>

<p><code>c
GString *sql = g_string_sized_new(0);
g_string_printf(sql,"INSERT INTO table (id, type) VALUES (%s, %s);",id,type);
g_string_erase(sql, 0, sql-&gt;len);
g_string_free(sql,1);
</code></p>

<p>还可以很方便的重复使用，但不要忘记最后的释放，关于释放函数的第二个参数是这样说明的：</p>

<blockquote><p>If free_segment is TRUE it also frees the character data. If it&rsquo;s FALSE, the caller gains ownership of the buffer and must free it after use with g_free().</p></blockquote>

<p>还有个常用的函数是<code>g_strsplit</code>，可以对字符进行分割,第三个参数表明需要分出几个来，0的话则一直切分到最后。</p>

<p>```c</p>

<pre><code>gchar **p = g_strsplit(line,",",0);
dispatch_request(source_id-&gt;str, p[3], p[0], p[2], p[1], p[4]);
g_strfreev(p);
</code></pre>

<p>```</p>

<p>当然，关于GLib还有很多有用的东西，用Dash下个文档慢慢翻着看一遍相信会很有收获的。</p>

<h3>3.Mysql</h3>

<p>有服务的地方就有数据库，对于这种简易的小服务，Mysql是必不可少的。</p>

<p>针对Mysql封了三个简单的函数方便调用：</p>

<p>```c</p>

<pre><code>MYSQL *db_connect(char *url, char *user_name, char *pwd, char *table_name) {
    MYSQL *conn_ptr;
    conn_ptr = mysql_init(NULL);
    if (!conn_ptr) {
        printf("mysql_init failed\n");
        return NULL;
    }
    conn_ptr = mysql_real_connect(conn_ptr, url, user_name, pwd, table_name, 0, NULL, 0);
    mysql_set_character_set(conn_ptr,"utf8");
    if (conn_ptr) {
        return conn_ptr;
    } else {
        return NULL;
    }
}
</code></pre>

<p>```</p>

<p>```c</p>

<pre><code>MYSQL_RES *db_query(MYSQL *conn_ptr, char *sql) {
    int res = mysql_query(conn_ptr, sql); //查询语句
    if (res) {
        printf("error:%s\n",mysql_error(conn_ptr));
        return NULL;
    } else {
        MYSQL_RES *res_ptr = mysql_store_result(conn_ptr);              //取出结果集
        printf("affected %lu rows\n",(unsigned long)mysql_affected_rows(conn_ptr));
        return res_ptr;
    }
}
</code></pre>

<p>```</p>

<p>返回的<code>res_ptr</code>需要手动释放：</p>

<p>```c</p>

<pre><code>mysql_free_result(res);
</code></pre>

<p>```
还有一个关闭函数：</p>

<p>```c</p>

<pre><code>void db_close(MYSQL *connfd) {
    mysql_close(connfd);
}
</code></pre>

<p>```
这样，在服务器起来时建立数据库的连接存为全局变量，每次直接拿来用就好了，下面是一个比较典型的使用场景：</p>

<p>```c</p>

<pre><code>GString *sql = g_string_sized_new(0);
g_string_printf(sql,"INSERT INTO table (id, type) VALUES (%s, %s);",id,type);
db_query(conn_ptr, sql-&gt;str);
g_string_erase(sql, 0, sql-&gt;len);
g_string_printf(sql,"SELECT uid FROM table WHERE pid = %s",target_id);
printf("find users sql2:%s\n", sql-&gt;str);
MYSQL_RES *res = db_query(conn_ptr, sql-&gt;str);
MYSQL_ROW sqlrow;
if (res) {
    while((sqlrow = mysql_fetch_row(res)))  {
        long to_id = strtol(sqlrow[0], NULL, 10);
        if (g_hash_table_contains(user_to_bev_map,GINT_TO_POINTER(to_id)) &amp;&amp; strcmp(sqlrow[0],source_id)) {
            struct bufferevent *bev = g_hash_table_lookup(user_to_bev_map,GINT_TO_POINTER(to_id));
            evbuffer_add_printf ((struct evbuffer *)bufferevent_get_output(bev), "%s\n",send_msg-&gt;str);
        }
    }
}
mysql_free_result(res);
g_string_free(sql,1);
g_string_free(send_msg,1);
</code></pre>

<p>```</p>

<h3>4.libevent</h3>

<h4>介绍</h4>

<p>libevent是个好东西，有了它一般的数量级的连接都不在话下了。关于这种大数量的连接是有专门的话题来讨论的-<a href="http://www.kegel.com/c10k.html">C10K</a>。</p>

<p>最开始尝试了多进程多线程，select阻塞之类的方法，最后才找到这里来，也算是按着故事的发展逻辑走了一遍符合剧情尿性吧&hellip;<a href="http://daniel.haxx.se/docs/poll-vs-select.html">这篇文章</a>写得不错，比较有指导性。</p>

<p>关于libevent上手说不上难，狠下心来多读几遍它的<a href="http://www.wangafu.net/~nickm/libevent-book/">Fast portable non-blocking network programming with Libevent</a>弄明白了个大概还是不成问题的。</p>

<p>它的优点是跨平台，可以针对不同的平台的阻塞实现相同的功能。对于我们来说只需要关心event这个东西就好了，至于是UNIX的select，Linux的epoll还是BSD的kqueue那是libevent的事情，它会在底层帮我们选择<a href="http://monkey.org/~provos/libevent/doxygen-2.0.1/">libevent Documentation</a>。</p>

<h4>原理</h4>

<p>原始的socket的连接是我们建立了连接，获得一个套接字，然后对这个套接字进行多路复用的读写。</p>

<p>而现在我们可以使用libevent提供的event将这个套接字包裹起来，针对这个event编写它特定的读写函数。因为libevent是事件驱动的，所以当读写缓冲区达到特定条件时便会自动调用我们事先定义好的函数进行逻辑处理。大大简化了编码人员的工作量，可以让我们将更多的精力集中到逻辑代码的编写上面来（恰恰是最无聊的部分&hellip;），所以这么看来，也算是对程序员傻瓜化了一下吧。</p>

<p>因为对event的读写涉及到缓冲区的东西，需要我们去按字节的读出来，这里libevent也很贴心的又帮我们简化了一下工作。除了event外还提供了<a href="http://www.wangafu.net/~nickm/libevent-book/Ref6_bufferevent.html">bufferevent</a>，看名字便知道这是专门针对读写字符准备的。这是网站上对它的介绍：</p>

<blockquote><p>Most of the time, an application wants to perform some amount of data buffering in addition to just responding to events.</p>

<p>When we want to write data, for example, the usual pattern runs something like:</p>

<ul>
<li><p>Decide that we want to write some data to a connection;</p></li>
<li><p>Put that data in a buffer.Wait for the connection to become writable;</p></li>
<li><p>Write as much of the data as we can;</p></li>
<li><p>Remember how much we wrote, and if we still have more data to write, wait for the connection to become writable again.</p></li>
</ul>


<p>This buffered IO pattern is common enough that Libevent provides a generic mechanism for it. A &ldquo;bufferevent&rdquo; consists of an underlying transport (like a socket), a read buffer, and a write buffer. Instead of regular events, which give callbacks when the underlying transport is ready to be read or written, a bufferevent invokes its user-supplied callbacks when it has read or written enough data.</p></blockquote>

<h4>使用</h4>

<p>我们可以将新建的监听套接字绑定在event上帮我们处理后续的事件：</p>

<p>```c</p>

<pre><code>struct event_base *base;
struct event *listener_event;
serveListen(&amp;listener);
evutil_make_socket_nonblocking(listener);
listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void *)base);
event_add(listener_event, NULL);
event_base_dispatch(base);
</code></pre>

<p>```</p>

<p>当有事件进入时它会主动调用<code>do_accept</code>：</p>

<p>```c
void do_accept(evutil_socket_t listener, short event, void *arg)
{</p>

<pre><code> struct event_base *base = arg;
struct sockaddr_storage ss;
socklen_t slen = sizeof(ss);
int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);
if (fd &lt; 0) {
    perror("accept");
} else if (fd &gt; FD_SETSIZE) {
    close(fd);
} else {
    struct bufferevent *bev;
    evutil_make_socket_nonblocking(fd);
    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, readcb, writecb, errorcb, GINT_TO_POINTER(fd));
    bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
    bufferevent_enable(bev, EV_READ|EV_WRITE);
}
</code></pre>

<p>}
```</p>

<p>从上面代码可以看出，我们从<code>accept</code>中接收回一个套接字，并将该套接字绑定在一个<code>bufferevent</code>，设置好相应的读写函数与读写触发的水位线加入到<code>base</code>里便可以从容的等待事件的触发了。</p>

<p>关于水位线，这里也有段详细的描述：</p>

<blockquote><p>Every bufferevent has two data-related callbacks: a read callback and a write callback. By default, the read callback is called whenever any data is read from the underlying transport, and the write callback is called whenever enough data from the output buffer is emptied to the underlying transport. You can override the behavior of these functions by adjusting the read and write &ldquo;watermarks&rdquo; of the bufferevent.</p>

<p>Every bufferevent has four watermarks:</p>

<ul>
<li><code>Read low-water mark</code></li>
</ul>


<p>Whenever a read occurs that leaves the bufferevent’s input buffer at this level or higher, the bufferevent’s read callback is invoked. Defaults to 0, so that every read results in the read callback being invoked.</p>

<ul>
<li><code>Read high-water mark</code></li>
</ul>


<p>If the bufferevent’s input buffer ever gets to this level, the bufferevent stops reading until enough data is drained from the input buffer to take us below it again. Defaults to unlimited, so that we never stop reading because of the size of the input buffer.</p>

<ul>
<li><code>Write low-water mark</code></li>
</ul>


<p>Whenever a write occurs that takes us to this level or below, we invoke the write callback. Defaults to 0, so that a write callback is not invoked unless the output buffer is emptied.</p>

<ul>
<li><code>Write high-water mark</code></li>
</ul>


<p>Not used by a bufferevent directly, this watermark can have special meaning when a bufferevent is used as the underlying transport of another bufferevent. See notes on filtering bufferevents below.</p></blockquote>

<p>细读一遍还是蛮获益匪浅的，大体意思为通过水位线的设置来触发读写的回调函数。</p>

<ul>
<li><p>对于读取水位，有读低水位与高水位，读低水位默认为0，即当buffer里数据量高于0时便会调用读回调，也就是一有数据便会回调，另一方面，当超过读的高水位时，buffer便会停止接受数据，这个值默认被置为<code>unlimited</code>，所以可以理解为永远不会停止接受数据。</p></li>
<li><p>对于写入水位，写的低水位表示当写出数据后buffer里剩余的数据量小于该水位时调用写函数，默认为0，即只有buffer被清空后该函数才会被回调。写的高水位比较特殊，一般情况下没有使用。</p></li>
</ul>


<p>对于水位线的设置是通过下面的函数实现的</p>

<p><code>c
void bufferevent_setwatermark(struct bufferevent *bufev, short events,size_t lowmark, size_t highmark);
ex:bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
</code></p>

<p>在回调函数里这样获取数据：</p>

<p>```c</p>

<pre><code>struct evbuffer *input = bufferevent_get_input(bev);
if ((line = evbuffer_readln(input, &amp;n, EVBUFFER_EOL_LF))) {
    gchar **p;
    p = g_strsplit(line,",",0);
    dispatch_request(u_data-&gt;u_id-&gt;str, p[3], p[0], p[2], p[1], p[4]);
    g_strfreev(p);
}
</code></pre>

<p>```</p>

<p>需要注意的是，提供的<code>evbuffer_readln</code>可以将接受到的一行数据自动去除<code>\n</code>，方便了我们的后期使用。</p>

<h2>二，实现思路</h2>

<p>具体的思路因为暂时在需求上不是很复杂所以比较简单。</p>

<p>首先实现了<code>do_accept</code>函数，阻塞接收请求建立连接的<code>socket</code>，当有新的<code>socket</code>进来后使用<code>bufferevent</code>将其包装好，并设置好它的首次读写回调函数。</p>

<p><code>c
struct bufferevent *bev;
evutil_make_socket_nonblocking(fd);
bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
bufferevent_setcb(bev, readcb, writecb, errorcb, GINT_TO_POINTER(fd));
bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
bufferevent_enable(bev, EV_READ|EV_WRITE);
</code></p>

<p>首次客户端的通信用于标示此次通信的目的，当为登录时，进入<code>reg_client</code>将该用户注册至服务器，并修改其回调函数用于具体的逻辑处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android USB Host通信]]></title>
    <link href="http://sonnewilling.com/blog/2014/04/30/android-usb-hosttong-xin/"/>
    <updated>2014-04-30T11:18:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/04/30/android-usb-hosttong-xin</id>
    <content type="html"><![CDATA[<h2>开了个头</h2>

<p>一部Android手机加上一块Arduino的板子通过USB通信可以实现很多有趣的东西。</p>

<p>2011年Google推出Android开放配件协议AOA及配件开发工具包ADK提供了Android USB或蓝牙进行通信的API，为基于Android系统的智能设备控制外设提供了条件。利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备 <a href="http://www.chinaaet.com/article/216691">原文</a>。</p>

<!-- more -->


<p>想来这便是Android的魅力所在，开源的Linux系统给了任何人实现自己的梦想的可能。无需再依靠大的厂商提供的一套套完整的服务。仅仅通过自己的想象力配以几块平淡无奇的板子，便能实现一些之前看起来很高大上的东西。</p>

<h2>利其器</h2>

<p>1.Android-<a href="http://developer.android.com/sdk/index.html">ADT</a></p>

<p>Android的简单开发依赖于工具包SDK和开发工具IDE的使用。Google为我们提供的ADT打包了完善的开发工具：</p>

<blockquote><p>Eclipse + ADT plugin</p>

<p>Android SDK Tools</p>

<p>Android Platform-tools</p>

<p>The latest Android platform</p>

<p>The latest Android system image for the emulator</p></blockquote>

<p>这里还不得不提的是一个关于Android模拟器的问题。用过eclipse的都知道，上面自带的模拟器速度奇慢，尤其当适应了iPhone开发后对其更是不能忍受。这里有一篇文章便是专门讲解了下为毛Android的模拟器这么慢-<a href="http://stackoverflow.com/questions/1584617/simulator-or-emulator-what-is-the-difference">Simulator or Emulator</a>。</p>

<p>然后便发现了这个神器-<a href="http://www.genymotion.com/">Genymotion</a>，感觉这玩意儿比苹果的模拟器还快。</p>

<p>2.<a href="http://www.arduino.cc/">Arduino</a></p>

<p>这个板子还是蛮便宜又好用的，官网的文档也全，基本跟着读一遍就知道大体的开发的流程了，提供的IDE有点坑，只能设为9号字体，倒是可以调大，调大的话光标根本对不上&hellip;</p>

<p><img src="/images/tec/androidusb/arduino.png" alt="image" /></p>

<p>示例的代码做了个简单的读数据的功能，每次读一行然后原样返回。</p>

<p>开头的setup那里设置了<a href="http://en.wikipedia.org/wiki/Baud">波特率</a>，大体上波特率跟每秒发送的信息量有关。手上的这块板子经过简单的测试，有如下数据：</p>

<blockquote><p>波特率为9600时，每次可以携带129个字节，间隔极限在150ms</p>

<p>波特率为14400时，每次可以携带191个字节，间隔极限在260ms</p></blockquote>

<p>个人推测大概越好的板子每次能携带的信息量越大且时间间隔越短吧，即所谓的可以支持很高的波特率。</p>

<p>有了上面这两套东西基本上就可以开始USB通信了。</p>

<h2>幕前</h2>

<p>关于详细的实现Google的教程上有个快速简易的介绍，一般跟着做是可以实现效果的-<a href="http://developer.android.com/guide/topics/connectivity/usb/index.html">USB Host and Accessory</a>。稍微了解过Android开发的看着玩意儿没啥问题。基本上就是在<code>manifest</code>里对指定的activity配置下权限就妥了，它还提供了一个<code>device_filter</code>的xml文件，可以过滤指定的USB设备。</p>

<p>因为要在Andorid上做开发然后测试与Arduino，所以免不了要先往Android上写程序再让这俩东西连接，老是这样往复的在几台设备间插拔效率太低，Google提供给我们的解决方案是让Android通过Wifi连电脑，然后Android与Arduino一直连着线就妥了。</p>

<p>照着试了几遍，别人的电脑一连就妥，我的死活不行，也不知是不是苹果机的缘故。无奈实在没有插来插去的兴趣，所以又研究了下Genymotion，因为它是依托在VirtualBox上的，总觉得可以一搞。</p>

<p>多次尝试后发现，可以先将Arduino板插上电脑，如下图会出现这个设备，添加虚拟机对它的过滤，这之后把板子拔下来再插回去的话虚拟机也即Android模拟器便可以接收到Arduino板子的信号了。想要对板子连电脑烧程序的话，则反过来，先取消对板子的过滤，插拔一次便连上电脑了。</p>

<p><img src="/images/tec/androidusb/usbbox.png" alt="image" /></p>

<p>具体的实现大体分为四步：<a href="http://developer.android.com/guide/topics/connectivity/usb/index.html">USB Host and Accessory</a></p>

<h4>一，Obtaining permission to communicate with a device</h4>

<p>先实例化一个<code>UsbManager</code>，通过它来获取USB连接的权限。</p>

<p>```java
UsbManager mUsbManager = (UsbManager) getSystemService(Context.USB_SERVICE);
private static final String ACTION_USB_PERMISSION =</p>

<pre><code>"com.android.example.USB_PERMISSION";
</code></pre>

<p>mPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);
IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
registerReceiver(mUsbReceiver, filter);
UsbDevice device;
mUsbManager.requestPermission(device, mPermissionIntent);
<code>
权限获取：
</code>java
private static final String ACTION_USB_PERMISSION =</p>

<pre><code>"com.android.example.USB_PERMISSION";
</code></pre>

<p>private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (ACTION_USB_PERMISSION.equals(action)) {
        synchronized (this) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                if(device != null){
                  //call method to set up device communication
               }
            } 
            else {
                Log.d(TAG, "permission denied for device " + device);
            }
        }
    }
}
</code></pre>

<p>};
```</p>

<h4>二，Enumerating devices</h4>

<p>```java
HashMap&lt;String, UsbDevice> deviceList = manager.getDeviceList();
Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();
while(deviceIterator.hasNext()){</p>

<pre><code>UsbDevice device = deviceIterator.next()
//your code
</code></pre>

<p>}
```</p>

<h4>三，Communicating with a device</h4>

<p><code>java
private Byte[] bytes
private static int TIMEOUT = 0;
private boolean forceClaim = true;
UsbInterface intf = device.getInterface(0);
UsbEndpoint endpoint = intf.getEndpoint(0);
UsbDeviceConnection connection = mUsbManager.openDevice(device);
connection.claimInterface(intf, forceClaim);
connection.bulkTransfer(endpoint, bytes, bytes.length, TIMEOUT); //do in another thread
</code></p>

<h4>四，Terminating communication with a device</h4>

<p>```java
BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction(); 
  if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
        UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
        if (device != null) {
            // call your method that cleans up and closes communication with the device
        }
    }
}
</code></pre>

<p>};
```</p>

<p>需要注意的是两者间的通讯都是以Byte形式完成的，所以作为在接收与发送的时候需要注意相关的转码工作，而且我这边实现的是一行行的读取，所以发送的时候会隐式地拼接上<code>\n</code>。</p>

<p>发送时的转码：</p>

<p>```java
private String changeEscapeSequence(String in) {</p>

<pre><code>String out = new String();
try {
    out = unescapeJava(in);
} catch (IOException e) {
    return "";
}
out = out + "\n";
return out;
</code></pre>

<p>} <br/>
private String unescapeJava(String str) throws IOException {</p>

<pre><code> if (str == null) {
     return "";
 }
 int sz = str.length();
 StringBuffer unicode = new StringBuffer(4);
 StringBuilder strout = new StringBuilder();
 boolean hadSlash = false;
 boolean inUnicode = false;
 for (int i = 0; i &lt; sz; i++) {
     char ch = str.charAt(i);
     if (inUnicode) {
         // if in unicode, then we're reading unicode
         // values in somehow
         unicode.append(ch);
         if (unicode.length() == 4) {
             // unicode now contains the four hex digits
             // which represents our unicode character
             try {
                 int value = Integer.parseInt(unicode.toString(), 16);
                 strout.append((char) value);
                 unicode.setLength(0);
                 inUnicode = false;
                 hadSlash = false;
             } catch (NumberFormatException nfe) {
                 // throw new NestableRuntimeException("Unable to parse unicode value: " + unicode, nfe);
                 throw new IOException("Unable to parse unicode value: " + unicode, nfe);
             }
         }
         continue;
     }
     if (hadSlash) {
         // handle an escaped value
         hadSlash = false;
         switch (ch) {
             case '\\':
                 strout.append('\\');
                 break;
             case '\'':
                 strout.append('\'');
                 break;
             case '\"':
                 strout.append('"');
                 break;
             case 'r':
                 strout.append('\r');
                 break;
             case 'f':
                 strout.append('\f');
                 break;
             case 't':
                 strout.append('\t');
                 break;
             case 'n':
                 strout.append('\n');
                 break;
             case 'b':
                 strout.append('\b');
                 break;
             case 'u':
                 {
                     // uh-oh, we're in unicode country....
                     inUnicode = true;
                     break;
                 }
             default :
                 strout.append(ch);
                 break;
         }
         continue;
     } else if (ch == '\\') {
         hadSlash = true;
         continue;
     }
     strout.append(ch);
 }
 if (hadSlash) {
     // then we're in the weird case of a \ at the end of the
     // string, let's output it anyway.
     strout.append('\\');
 }
 return new String(strout.toString());
</code></pre>

<p>}
```</p>

<p>接收时的转码：</p>

<p>```java
void setSerialDataToTextView(int disp, byte[] rbuf, int len, String sCr, String sLf) {</p>

<pre><code>for (int i = 0; i &lt; len; ++i) {
    mText.append((char) rbuf[i]);
}
</code></pre>

<p>}
```</p>

<h2>正主</h2>

<p>其实最后在各种测试的时候没有用Google的这个原始流程，在网上发现了一份比较完整的USB通讯示例流程-<a href="https://github.com/ksksue/Android-USB-Serial-Monitor-Lite">Android-USB-Serial-Monitor-Lite</a>，直接用它提供的各种工具做的测试&hellip;我的测试代码在这里<a href="https://github.com/wanax/android_usb_test">android_usb_test</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX下的Socket通信-TCP/IP基本概念]]></title>
    <link href="http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-tcp-slash-ipji-ben-gai-nian/"/>
    <updated>2014-03-20T18:44:00+08:00</updated>
    <id>http://sonnewilling.com/blog/2014/03/20/unixxia-de-sockettong-xin-tcp-slash-ipji-ben-gai-nian</id>
    <content type="html"><![CDATA[<h2>总览</h2>

<blockquote><p>All problems in computer science can be solved by another level of indirection</p></blockquote>

<p>觉得这句话对TCP的分层也很适用。</p>

<p>对TCP/IP协议来说，大体分为五层，</p>

<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ol>


<p>应用层我们接触的比较多，流行的如HTTP，FTP之类都算，像我在大学里做的PHP开发时基本对HTTP发包没有任何概念，照着教程开eclipse，apache，在浏览器里敲个<code>locahost:8080</code>出来个猫的图案就很开心了。再建个index，上面写句“未满18周岁禁止进入”，就有种天下在手的感觉。</p>

<!--more-->


<p>后来做java网站，用到了HttpClient，逐渐对HTTP的抓包发包有了简单地了解。通过这玩意儿就可以做到绕过网页填写，直接后台模拟网页提交表单，那些抢票软件大体上就是这个思路。</p>

<p>再往下便是闻名已久的传输层（TCP,UPD,SCTP etc.）与网络层(IPv4,IPv6 etc.)了。</p>

<h2>网络的划分</h2>

<p><img src="/images/tec/Socket/hierarchy.png" alt="image" /></p>

<p>通过上图可以很直观的看到应用层的实体数据经过层层的包装最终封印在了链路层中在物理层中进行传输。其中每一层实体间交换的单位信息称为<em>协议数据单元(protocol data unit,PDU)</em>。每层的PDU作为下层的<em>数据服务单元（service data unit,SDU）</em>传递给下层，并由下层间接完成本层的PDU交换。</p>

<p>为了避免诸如TCP的PDU，IP的PDU这类很不简洁的称呼，国际上给每层的PDU都另外取了自己的名字。传输层的称为<em>segment（分节）</em>，网络层的称为<em>IP datagram（IP数据报）</em>，链路层的称为<em>frame（帧）</em></p>

<p>而关于层与层间的打包封印也有它们不得不说的故事，那就是分片。简单的说如果本层PDU的大小超过紧邻下层的最大SDU限制，那么本层还要事先把PDU划分成若干个合适的片段让下层分开载送，再在相反方向把这些片段重组成PDU。同一层内SDU作为PDU的净荷（payload）字段出现，因此可以说上层PDU作为本层的SDU字段由本层PDU承载。如上图所示每层PDU除用于承载紧邻上层的PDU（即承载数据外），也用于承载本层协议内部通讯所需的控制信息（各种header）。</p>

<p>当然这只是个初步的说法，下面会针对传输层与网络层展开具体一下的学习。</p>

<h3>1.传输层</h3>

<p>一说传输层TCP，讲不通三次握手连接，四次握手关闭都不好意思出来混。</p>

<h4>先看连接图示：</h4>

<p><img src="/images/tec/Socket/connect.JPG" alt="image" /></p>

<p>图中有类似于SYN，ACK的标记量，结合上一章的内容，其实这也是TCP分节的一种。分节除了用于承载数据外，也用于建立连接（SYN分节），终止连接（FIN分节），中止连接（RST分节），确认数据接收（ACK分节），刷送待发数据（PSH分节）和携带紧急数据指针（URG分节），而且这些功能（包括承载数据）可以灵活组合。</p>

<p>也就是说在建立连接的初期，由Socket自带的函数为我们发送分节握手沟通，握手连接建立后，则由用户自行组织分节信息进行通信。</p>

<p>关于上图的握手过程可以简单复述一下：</p>

<ol>
<li>服务器必须准备好接受外来的连接，这通常通过调用<code>socket</code>,<code>bind</code>,<code>listen</code>这三个函数来完成，称之为<em>被动打开（passive open）</em>。</li>
<li>客户通过调用<code>connect</code>发起<em>主动打开（active open）</em>。这导致客户TCP发送一个SYN（同步）分节，它告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部，一个TCP首部及可能有的TCP选项。</li>
<li>服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。</li>
<li>客户必须确认服务器的SYN。</li>
</ol>


<p>上述过程中出现了<em>SYN_SENT</em>之类的字样，它们代表了套接字的状态。在<code>socket</code>函数初始化后套接字的状态为<em>CLOSED</em>，<code>connect</code>函数导致当前套接字从<em>CLOSED</em>状态转移到<em>SYN_SENT</em>状态，若成功则在转移到<em>ESTABLISHED</em>状态。<em>若<code>connect</code>失败则该套接字不再可用，必须关闭，不可以对这样的套接字再次调用<code>connect</code>函数，而是在每次失败后，必须<code>close</code>当前的套接字描述符并重新调用<code>socket</code></em>。</p>

<h4>再来个关闭图示：</h4>

<p><img src="/images/tec/Socket/close.JPG" alt="image" /></p>

<ol>
<li>某个应用进程首先调用<code>close</code>，称该端执行<em>主动关闭（active close）</em>，该端的TCP于是发送一个FIN终止分节，表示数据发送完毕。</li>
<li>接收到这个FIN对端执行<em>被动关闭（passive close）</em>。这个FIN由TCP确认。它的接收也作为一个<em>文件结束符（end-of-file）</em>传递给接收端应用进程（放在已排队等候该应用进程接收的任何其它数据之后），因为FIN的接收意味着接收端应用进程在相应连接上再无额外的数据可接收。</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用<code>close</code>关闭它的套接字。这导致了它的TCP也发送一个FIN。</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li>
</ol>


<p>在握手连接的过程中，套接字通过发送SYN（建立连接分节）经历了COLSE，SYN_SENT，ESTABLISHED等状态，达到了可以通信的目的。而在四次关闭握手连接中，套接字也要经历几种状态，达到真正关闭的目的，<em>需要注意的是，因为TCP是全双工的，所以正常情况下的关闭需要经过双方的确认才可以完全关闭，这就需要通信两端都分别发送自己的FIN信号，且回应对方的FIN，因此理论上关闭握手需要四次，每个套接字各两次。</em></p>

<ol>
<li>FIN_WAIT_1：<em>主动方</em>套接字在ESTABLISHED状态正常通信时，它想主动关闭连接，于是向对方发送了FIN报文，此时该套接字即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。</li>
<li>FIN_WAIT_2：<em>主动方</em>通俗的讲便是我已经完成任务并且告知对端完成我方的关闭，然后我在等你发送你的FIN，要是你还有什么话说那赶紧，我这边该说的都说完了&hellip;</li>
<li>CLOSE_WAIT：<em>被动方</em>对应的是FIN_WAIT_2状态，便是在正常ESTABLISHED状态下收到了对端的FIN信号，但我还有活没做完，需要搞定后才往你那儿发送FIN终止信号，此时的状态便是CLOSE_WAIT。</li>
<li>LAST_ACK：<em>被动方</em>被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。</li>
<li>TIME_WAIT：<em>主动方</em>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
</ol>


<p>在这些状态中，比较不好理解的是TIME_WAIT状态。我们看到执行主动关闭的一方经历了这个状态。该端点停留在这个状态的持续时间是<em>最长分节生命期（maximum segment lifetime，MSL）</em>的两倍，有时候称之为2MSL。</p>

<p>任何TCP实现都必须为MSL选择一个值。其时间在1分钟到4分钟之间。MSL是任何IP数据报能够在因特网中存活的最长时间。因为每个数据报含有一个称为<em>跳限（hop limit）</em>的8位字段，它的最大值为255.一般上假设：</p>

<blockquote><p>具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒。</p></blockquote>

<p>所以TIME_WAIT状态有两个存在的理由，</p>

<ol>
<li>可靠地实现TCP全双工连接的终止。TCP连接在主动关闭方发送的最后一个ACK(FIN)，有可能丢失，这时被动方会重新发FIN, 如果这时主动方处于CLOSED状态 ，就会响应RST而不是ACK。所以主动方要处于TIME_WAIT状态，而不能是CLOSED。</li>
<li>允许老的重复分节在网络中消逝，因为经过2MSL，上一次连接中所有的重复包都会消失。</li>
</ol>


<p>最后放一张TCP中套接字的状态大图~</p>

<p><img src="/images/tec/Socket/status.png" alt="image" /></p>

<h3>2.网络层</h3>

<p>因为主体是使用TCP的Socket进行编程，这里对网络层的具体细节就不做探讨了。但关于网络层还会牵扯到分片的问题，这里需要重视起来。</p>

<p>在TCP传输层中，发送端TCP把来自应用进程的字节流数据（即由应用进程通过一次次输出操作写出到发送端TCP套接字中的数据）按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据既可能是发送端应用进程单次输出操作的结果，也可能是数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于可在连接建立阶段由对端通告的<em>最大分节大小（maximum segment size,MSS）</em>以及<em>外出接口的最大传输单元（maximum transmission unit,MTU）</em>或<em>外出路径的路径MTU</em>。</p>

<p>MSS的目的是告诉对端其重组缓冲区大小的实际值，从而试图避免分片。MSS经常设置成MTU减去IP和TCP首部的固定长度。</p>

<p>网络层实体间交换的PDU称为IP数据报（IP datagram）,其长度有限：IPv4数据报最大长度65535字节，IPv6S数据报最大65575.发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中发送。链路层实体间交换的PDU称为帧（frame），其长度取决于具体的接口。IP数据报由IP首部和所承载的传输层数据（即网络层的SDU）构成。过长的IP数据报无法封装在单个帧中，需要先对其SDU进行分片（fragmentation），再把分成的各个片段（fragment）冠以新的IP首部封装到多个帧中。在一个IP数据报从源端到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中，而其逆操作即重组（reassembly）一般只发生在目的端。</p>

<p>TCP/IP协议族为提高效率会尽可能避免IP的分片/重组操作：TCP根据MSS和MTU限定每个分节的大小，且在途中尽量避免分片操作。不论是否分片都由IP作为链路层的SDU传入链路层，并由链路层封装在帧中数据称为分组（packet，俗称包）。可见一个分组既可能是一个完整地IP数据报，也可能是某个IP数据报的SDU的一个片段被冠以新的IP首部后的结果。</p>

<h2>下一步</h2>

<p>总结了基本套接字函数的使用与TCP/IP的简单概念，下一步将会着手编写一套客户/服务器的通信演示Demo，会考虑实现线程池来提高并发效率。</p>
]]></content>
  </entry>
  
</feed>
